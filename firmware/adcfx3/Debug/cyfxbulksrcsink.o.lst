   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"cyfxbulksrcsink.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.global	CyFxGpifTransition
  22              		.data
  23              		.align	2
  26              	CyFxGpifTransition:
  27 0000 0000     		.short	0
  28 0002 FFFF     		.short	-1
  29 0004 AAAA     		.short	-21846
  30              		.global	CyFxGpifWavedata
  31 0006 0000     		.align	2
  34              	CyFxGpifWavedata:
  35 0008 019C731E 		.word	510893057
  36 000c 00010000 		.word	256
  37 0010 800000C0 		.word	-1073741696
  38 0014 00000000 		.word	0
  39 0018 00000000 		.word	0
  40 001c 00000000 		.word	0
  41 0020 0294732E 		.word	779326466
  42 0024 C0000020 		.word	536871104
  43 0028 40000080 		.word	-2147483584
  44 002c 00000000 		.word	0
  45 0030 00000000 		.word	0
  46 0034 00000000 		.word	0
  47 0038 039C731E 		.word	510893059
  48 003c 00000000 		.word	0
  49 0040 00000080 		.word	-2147483648
  50 0044 00000000 		.word	0
  51 0048 00000000 		.word	0
  52 004c 00000000 		.word	0
  53              		.global	CyFxGpifWavedataPosition
  54              		.align	2
  57              	CyFxGpifWavedataPosition:
  58 0050 00       		.byte	0
  59 0051 01       		.byte	1
  60 0052 02       		.byte	2
  61 0053 00       		.byte	0
  62              		.global	CyFxGpifRegValue
  63              		.align	2
  66              	CyFxGpifRegValue:
  67 0054 80830080 		.word	-2147449984
  68 0058 6C000000 		.word	108
  69 005c 00000000 		.word	0
  70 0060 46000000 		.word	70
  71 0064 00000000 		.word	0
  72 0068 00000000 		.word	0
  73 006c 00000000 		.word	0
  74 0070 82000000 		.word	130
  75 0074 82070000 		.word	1922
  76 0078 00000000 		.word	0
  77 007c FFFF0000 		.word	65535
  78 0080 00000000 		.word	0
  79 0084 00000000 		.word	0
  80 0088 00000000 		.word	0
  81 008c 00000000 		.word	0
  82 0090 00000000 		.word	0
  83 0094 00000000 		.word	0
  84 0098 00000000 		.word	0
  85 009c 00000000 		.word	0
  86 00a0 00000000 		.word	0
  87 00a4 00000000 		.word	0
  88 00a8 00000000 		.word	0
  89 00ac 00000000 		.word	0
  90 00b0 00000000 		.word	0
  91 00b4 00000000 		.word	0
  92 00b8 00000000 		.word	0
  93 00bc 00000000 		.word	0
  94 00c0 00000000 		.word	0
  95 00c4 00000000 		.word	0
  96 00c8 06000000 		.word	6
  97 00cc 00000000 		.word	0
  98 00d0 FFFF0000 		.word	65535
  99 00d4 0A010000 		.word	266
 100 00d8 00000000 		.word	0
 101 00dc FFFF0000 		.word	65535
 102 00e0 00000000 		.word	0
 103 00e4 FFFF0000 		.word	65535
 104 00e8 09010000 		.word	265
 105 00ec 00000000 		.word	0
 106 00f0 0A000000 		.word	10
 107 00f4 00000000 		.word	0
 108 00f8 00000000 		.word	0
 109 00fc 00000000 		.word	0
 110 0100 00000000 		.word	0
 111 0104 00000000 		.word	0
 112 0108 00000000 		.word	0
 113 010c 00000000 		.word	0
 114 0110 00000000 		.word	0
 115 0114 00000000 		.word	0
 116 0118 00000000 		.word	0
 117 011c 00000000 		.word	0
 118 0120 00000000 		.word	0
 119 0124 00000000 		.word	0
 120 0128 00000000 		.word	0
 121 012c 00000000 		.word	0
 122 0130 00000000 		.word	0
 123 0134 00000000 		.word	0
 124 0138 00000000 		.word	0
 125 013c 00000000 		.word	0
 126 0140 00000000 		.word	0
 127 0144 00000000 		.word	0
 128 0148 00000000 		.word	0
 129 014c 00000000 		.word	0
 130 0150 00040180 		.word	-2147417088
 131 0154 01040180 		.word	-2147417087
 132 0158 02040180 		.word	-2147417086
 133 015c 03040180 		.word	-2147417085
 134 0160 00000000 		.word	0
 135 0164 00000000 		.word	0
 136 0168 00000000 		.word	0
 137 016c 00000000 		.word	0
 138 0170 00000000 		.word	0
 139 0174 00000000 		.word	0
 140 0178 00000000 		.word	0
 141 017c 00000000 		.word	0
 142 0180 C1FFFFFF 		.word	-63
 143              		.global	CyFxGpifConfig
 144              		.section	.rodata
 145              		.align	2
 148              	CyFxGpifConfig:
 149 0000 0400     		.short	4
 150 0002 0000     		.space	2
 151 0004 00000000 		.word	CyFxGpifWavedata
 152 0008 00000000 		.word	CyFxGpifWavedataPosition
 153 000c 0300     		.short	3
 154 000e 0000     		.space	2
 155 0010 00000000 		.word	CyFxGpifTransition
 156 0014 4C00     		.short	76
 157 0016 0000     		.space	2
 158 0018 00000000 		.word	CyFxGpifRegValue
 159              		.comm	bulkSrcSinkAppThread,168,4
 160              		.comm	glChHandleBulkSink,160,4
 161              		.comm	glChHandleBulkSrc,160,4
 162              		.global	glIsApplnActive
 163              		.bss
 164              		.align	2
 167              	glIsApplnActive:
 168 0000 00000000 		.space	4
 169              		.global	glDMARxCount
 170              		.align	2
 173              	glDMARxCount:
 174 0004 00000000 		.space	4
 175              		.global	glDMATxCount
 176              		.align	2
 179              	glDMATxCount:
 180 0008 00000000 		.space	4
 181              		.global	glDataTransStarted
 182              		.align	2
 185              	glDataTransStarted:
 186 000c 00000000 		.space	4
 187              		.global	StandbyModeEnable
 188              		.align	2
 191              	StandbyModeEnable:
 192 0010 00000000 		.space	4
 193              		.global	TriggerStandbyMode
 194              		.align	2
 197              	TriggerStandbyMode:
 198 0014 00000000 		.space	4
 199              		.global	glForceLinkU2
 200              		.align	2
 203              	glForceLinkU2:
 204 0018 00000000 		.space	4
 205              		.global	glEp0StatCount
 206              		.align	2
 209              	glEp0StatCount:
 210 001c 00000000 		.space	4
 211              		.comm	glEp0Buffer,32,32
 212              		.comm	glBulkLpEvent,40,4
 213              		.comm	gl_setupdat0,4,4
 214              		.comm	gl_setupdat1,4,4
 215              		.global	gl_UsbLogBuffer
 216              		.align	2
 219              	gl_UsbLogBuffer:
 220 0020 00000000 		.space	4
 221              		.text
 222              		.align	2
 223              		.global	CyFxAppErrorHandler
 225              	CyFxAppErrorHandler:
 226              	.LFB0:
 227              		.file 1 "../cyfxbulksrcsink.c"
   1:../cyfxbulksrcsink.c **** /*
   2:../cyfxbulksrcsink.c ****  ## Cypress USB 3.0 Platform source file (cyfxbulksrcsink.c)
   3:../cyfxbulksrcsink.c ****  ## ===========================
   4:../cyfxbulksrcsink.c ****  ##
   5:../cyfxbulksrcsink.c ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2011,
   6:../cyfxbulksrcsink.c ****  ##  All Rights Reserved
   7:../cyfxbulksrcsink.c ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../cyfxbulksrcsink.c ****  ##
   9:../cyfxbulksrcsink.c ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../cyfxbulksrcsink.c ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../cyfxbulksrcsink.c ****  ##
  12:../cyfxbulksrcsink.c ****  ##  Use of this file is governed
  13:../cyfxbulksrcsink.c ****  ##  by the license agreement included in the file
  14:../cyfxbulksrcsink.c ****  ##
  15:../cyfxbulksrcsink.c ****  ##     <install>/license/license.txt
  16:../cyfxbulksrcsink.c ****  ##
  17:../cyfxbulksrcsink.c ****  ##  where <install> is the Cypress software
  18:../cyfxbulksrcsink.c ****  ##  installation root directory path.
  19:../cyfxbulksrcsink.c ****  ##
  20:../cyfxbulksrcsink.c ****  ## ===========================
  21:../cyfxbulksrcsink.c **** */
  22:../cyfxbulksrcsink.c **** 
  23:../cyfxbulksrcsink.c **** /* This file illustrates the bulk source sink application example using the DMA MANUAL_IN
  24:../cyfxbulksrcsink.c ****    and DMA MANUAL_OUT mode */
  25:../cyfxbulksrcsink.c **** 
  26:../cyfxbulksrcsink.c **** /*
  27:../cyfxbulksrcsink.c ****    This example illustrates USB endpoint data source and data sink mechanism. The example
  28:../cyfxbulksrcsink.c ****    comprises of vendor class USB enumeration descriptors with 2 bulk endpoints. A bulk OUT
  29:../cyfxbulksrcsink.c ****    endpoint acts as the producer of data and acts as the sink to the host. A bulk IN endpoint
  30:../cyfxbulksrcsink.c ****    acts as the consumer of data and acts as the source to the host.
  31:../cyfxbulksrcsink.c **** 
  32:../cyfxbulksrcsink.c ****    The data source and sink is achieved with the help of a DMA MANUAL IN channel and a DMA
  33:../cyfxbulksrcsink.c ****    MANUAL OUT channel. A DMA MANUAL IN channel is created between the producer USB bulk
  34:../cyfxbulksrcsink.c ****    endpoint and the CPU. A DMA MANUAL OUT channel is created between the CPU and the consumer
  35:../cyfxbulksrcsink.c ****    USB bulk endpoint. Data is received in the IN channel DMA buffer from the host through the
  36:../cyfxbulksrcsink.c ****    producer endpoint. CPU is signalled of the data reception using DMA callbacks. The CPU
  37:../cyfxbulksrcsink.c ****    discards this buffer. This leads to the sink mechanism. A constant patern data is loaded
  38:../cyfxbulksrcsink.c ****    onto the OUT Channel DMA buffer whenever the buffer is available. CPU issues commit of
  39:../cyfxbulksrcsink.c ****    the DMA data transfer to the consumer endpoint which then gets transferred to the host.
  40:../cyfxbulksrcsink.c ****    This leads to a constant source mechanism.
  41:../cyfxbulksrcsink.c **** 
  42:../cyfxbulksrcsink.c ****    The DMA buffer size is defined based on the USB speed. 64 for full speed, 512 for high speed
  43:../cyfxbulksrcsink.c ****    and 1024 for super speed. CY_FX_BULKSRCSINK_DMA_BUF_COUNT in the header file defines the
  44:../cyfxbulksrcsink.c ****    number of DMA buffers.
  45:../cyfxbulksrcsink.c ****    
  46:../cyfxbulksrcsink.c ****    For performance optimizations refer the readme.txt
  47:../cyfxbulksrcsink.c ****  */
  48:../cyfxbulksrcsink.c **** 
  49:../cyfxbulksrcsink.c **** #include "cyu3system.h"
  50:../cyfxbulksrcsink.c **** #include "cyu3os.h"
  51:../cyfxbulksrcsink.c **** #include "cyu3dma.h"
  52:../cyfxbulksrcsink.c **** #include "cyu3error.h"
  53:../cyfxbulksrcsink.c **** #include "cyfxbulksrcsink.h"
  54:../cyfxbulksrcsink.c **** #include "cyu3usb.h"
  55:../cyfxbulksrcsink.c **** #include "cyu3uart.h"
  56:../cyfxbulksrcsink.c **** #include "cyu3gpio.h"
  57:../cyfxbulksrcsink.c **** #include "cyu3utils.h"
  58:../cyfxbulksrcsink.c **** #include "cyfxgpif2config.h"
  59:../cyfxbulksrcsink.c **** 
  60:../cyfxbulksrcsink.c **** CyU3PThread     bulkSrcSinkAppThread;	 /* Application thread structure */
  61:../cyfxbulksrcsink.c **** CyU3PDmaChannel glChHandleBulkSink;      /* DMA MANUAL_IN channel handle.          */
  62:../cyfxbulksrcsink.c **** CyU3PDmaChannel glChHandleBulkSrc;       /* DMA MANUAL_OUT channel handle.         */
  63:../cyfxbulksrcsink.c **** 
  64:../cyfxbulksrcsink.c **** CyBool_t glIsApplnActive = CyFalse;      /* Whether the source sink application is active or not. *
  65:../cyfxbulksrcsink.c **** uint32_t glDMARxCount = 0;               /* Counter to track the number of buffers received. */
  66:../cyfxbulksrcsink.c **** uint32_t glDMATxCount = 0;               /* Counter to track the number of buffers transmitted. */
  67:../cyfxbulksrcsink.c **** CyBool_t glDataTransStarted = CyFalse;   /* Whether DMA transfer has been started after enumeration
  68:../cyfxbulksrcsink.c **** CyBool_t StandbyModeEnable  = CyFalse;   /* Whether standby mode entry is enabled. */
  69:../cyfxbulksrcsink.c **** CyBool_t TriggerStandbyMode = CyFalse;   /* Request to initiate standby entry. */
  70:../cyfxbulksrcsink.c **** CyBool_t glForceLinkU2      = CyFalse;   /* Whether the device should try to initiate U2 mode. */
  71:../cyfxbulksrcsink.c **** 
  72:../cyfxbulksrcsink.c **** volatile uint32_t glEp0StatCount = 0;           /* Number of EP0 status events received. */
  73:../cyfxbulksrcsink.c **** uint8_t glEp0Buffer[32] __attribute__ ((aligned (32))); /* Local buffer used for vendor command han
  74:../cyfxbulksrcsink.c **** 
  75:../cyfxbulksrcsink.c **** /* Control request related variables. */
  76:../cyfxbulksrcsink.c **** CyU3PEvent glBulkLpEvent;       /* Event group used to signal the thread that there is a pending re
  77:../cyfxbulksrcsink.c **** uint32_t   gl_setupdat0;        /* Variable that holds the setupdat0 value (bmRequestType, bRequest
  78:../cyfxbulksrcsink.c **** uint32_t   gl_setupdat1;        /* Variable that holds the setupdat1 value (wIndex and wLength). */
  79:../cyfxbulksrcsink.c **** #define CYFX_USB_CTRL_TASK      (1 << 0)        /* Event that indicates that there is a pending USB
  80:../cyfxbulksrcsink.c **** #define CYFX_USB_HOSTWAKE_TASK  (1 << 1)        /* Event that indicates the a Remote Wake should be
  81:../cyfxbulksrcsink.c **** 
  82:../cyfxbulksrcsink.c **** /* Buffer used for USB event logs. */
  83:../cyfxbulksrcsink.c **** uint8_t *gl_UsbLogBuffer = NULL;
  84:../cyfxbulksrcsink.c **** #define CYFX_USBLOG_SIZE        (0x1000)
  85:../cyfxbulksrcsink.c **** 
  86:../cyfxbulksrcsink.c **** /* GPIO used for testing IO state retention when switching from boot firmware to full firmware. */
  87:../cyfxbulksrcsink.c **** #define FX3_GPIO_TEST_OUT               (50)
  88:../cyfxbulksrcsink.c **** #define FX3_GPIO_TO_LOFLAG(gpio)        (1 << (gpio))
  89:../cyfxbulksrcsink.c **** #define FX3_GPIO_TO_HIFLAG(gpio)        (1 << ((gpio) - 32))
  90:../cyfxbulksrcsink.c **** 
  91:../cyfxbulksrcsink.c **** 
  92:../cyfxbulksrcsink.c **** /* Application Error Handler */
  93:../cyfxbulksrcsink.c **** void
  94:../cyfxbulksrcsink.c **** CyFxAppErrorHandler (
  95:../cyfxbulksrcsink.c ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
  96:../cyfxbulksrcsink.c ****         )
  97:../cyfxbulksrcsink.c **** {
 228              		.loc 1 97 0
 229              		.cfi_startproc
 230              		@ args = 0, pretend = 0, frame = 8
 231              		@ frame_needed = 1, uses_anonymous_args = 0
 232 0000 00482DE9 		stmfd	sp!, {fp, lr}
 233              	.LCFI0:
 234              		.cfi_def_cfa_offset 8
 235 0004 04B08DE2 		add	fp, sp, #4
 236              		.cfi_offset 14, -4
 237              		.cfi_offset 11, -8
 238              	.LCFI1:
 239              		.cfi_def_cfa 11, 4
 240 0008 08D04DE2 		sub	sp, sp, #8
 241 000c 08000BE5 		str	r0, [fp, #-8]
 242              	.L2:
  98:../cyfxbulksrcsink.c ****     /* Application failed with the error code apiRetStatus */
  99:../cyfxbulksrcsink.c **** 
 100:../cyfxbulksrcsink.c ****     /* Add custom debug or recovery actions here */
 101:../cyfxbulksrcsink.c **** 
 102:../cyfxbulksrcsink.c ****     /* Loop Indefinitely */
 103:../cyfxbulksrcsink.c ****     for (;;)
 104:../cyfxbulksrcsink.c ****     {
 105:../cyfxbulksrcsink.c ****         /* Thread sleep : 100 ms */
 106:../cyfxbulksrcsink.c ****         CyU3PThreadSleep (100);
 243              		.loc 1 106 0 discriminator 1
 244 0010 6400A0E3 		mov	r0, #100
 245 0014 FEFFFFEB 		bl	_tx_thread_sleep
 107:../cyfxbulksrcsink.c ****     }
 246              		.loc 1 107 0 discriminator 1
 247 0018 FCFFFFEA 		b	.L2
 248              		.cfi_endproc
 249              	.LFE0:
 251              		.section	.rodata
 252              		.align	2
 253              	.LC0:
 254 001c 43795533 		.ascii	"CyU3PDmaChannelDiscardBuffer failed, Error code = %"
 254      50446D61 
 254      4368616E 
 254      6E656C44 
 254      69736361 
 255 004f 640A00   		.ascii	"d\012\000"
 256 0052 0000     		.align	2
 257              	.LC1:
 258 0054 43795533 		.ascii	"CyU3PDmaChannelCommitBuffer failed, Error code = %d"
 258      50446D61 
 258      4368616E 
 258      6E656C43 
 258      6F6D6D69 
 259 0087 0A00     		.ascii	"\012\000"
 260 0089 000000   		.align	2
 261              	.LC2:
 262 008c 43795533 		.ascii	"CyU3PDmaChannelGetBuffer failed, Error code = %d\012"
 262      50446D61 
 262      4368616E 
 262      6E656C47 
 262      65744275 
 263 00bd 00       		.ascii	"\000"
 264              		.text
 265              		.align	2
 266              		.global	CyFxBulkSrcSinkDmaCallback
 268              	CyFxBulkSrcSinkDmaCallback:
 269              	.LFB1:
 108:../cyfxbulksrcsink.c **** }
 109:../cyfxbulksrcsink.c **** 
 110:../cyfxbulksrcsink.c **** #if 0
 111:../cyfxbulksrcsink.c **** /* This function initializes the debug module. The debug prints
 112:../cyfxbulksrcsink.c ****  * are routed to the UART and can be seen using a UART console
 113:../cyfxbulksrcsink.c ****  * running at 115200 baud rate. */
 114:../cyfxbulksrcsink.c **** void
 115:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnDebugInit (void)
 116:../cyfxbulksrcsink.c **** {
 117:../cyfxbulksrcsink.c ****     CyU3PGpioClock_t  gpioClock;
 118:../cyfxbulksrcsink.c ****     CyU3PUartConfig_t uartConfig;
 119:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 120:../cyfxbulksrcsink.c **** 
 121:../cyfxbulksrcsink.c ****     /* Initialize the GPIO block. If we are transitioning from the boot app, we can verify whether 
 122:../cyfxbulksrcsink.c ****        state is retained. */
 123:../cyfxbulksrcsink.c ****     gpioClock.fastClkDiv = 2;
 124:../cyfxbulksrcsink.c ****     gpioClock.slowClkDiv = 32;
 125:../cyfxbulksrcsink.c ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_16;
 126:../cyfxbulksrcsink.c ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK_BY_2;
 127:../cyfxbulksrcsink.c ****     gpioClock.halfDiv    = 0;
 128:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 129:../cyfxbulksrcsink.c **** 
 130:../cyfxbulksrcsink.c ****     /* When FX3 is restarting from standby mode, the GPIO block would already be ON and need not be
 131:../cyfxbulksrcsink.c ****        again. */
 132:../cyfxbulksrcsink.c ****     if ((apiRetStatus != 0) && (apiRetStatus != CY_U3P_ERROR_ALREADY_STARTED))
 133:../cyfxbulksrcsink.c ****     {
 134:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 135:../cyfxbulksrcsink.c ****     }
 136:../cyfxbulksrcsink.c ****     else
 137:../cyfxbulksrcsink.c ****     {
 138:../cyfxbulksrcsink.c ****         /* Set the test GPIO as an output and update the value to 1. */
 139:../cyfxbulksrcsink.c ****         CyU3PGpioSimpleConfig_t testConf = {CyTrue, CyTrue, CyTrue, CyFalse, CY_U3P_GPIO_NO_INTR};
 140:../cyfxbulksrcsink.c **** 
 141:../cyfxbulksrcsink.c ****         apiRetStatus = CyU3PGpioSetSimpleConfig (FX3_GPIO_TEST_OUT, &testConf);
 142:../cyfxbulksrcsink.c ****         if (apiRetStatus != 0)
 143:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler (apiRetStatus);
 144:../cyfxbulksrcsink.c ****     }
 145:../cyfxbulksrcsink.c **** 
 146:../cyfxbulksrcsink.c ****     /* Initialize the UART for printing debug messages */
 147:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUartInit();
 148:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 149:../cyfxbulksrcsink.c ****     {
 150:../cyfxbulksrcsink.c ****         /* Error handling */
 151:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 152:../cyfxbulksrcsink.c ****     }
 153:../cyfxbulksrcsink.c **** 
 154:../cyfxbulksrcsink.c ****     /* Set UART configuration */
 155:../cyfxbulksrcsink.c ****     CyU3PMemSet ((uint8_t *)&uartConfig, 0, sizeof (uartConfig));
 156:../cyfxbulksrcsink.c ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 157:../cyfxbulksrcsink.c ****     uartConfig.stopBit = CY_U3P_UART_ONE_STOP_BIT;
 158:../cyfxbulksrcsink.c ****     uartConfig.parity = CY_U3P_UART_NO_PARITY;
 159:../cyfxbulksrcsink.c ****     uartConfig.txEnable = CyTrue;
 160:../cyfxbulksrcsink.c ****     uartConfig.rxEnable = CyFalse;
 161:../cyfxbulksrcsink.c ****     uartConfig.flowCtrl = CyFalse;
 162:../cyfxbulksrcsink.c ****     uartConfig.isDma = CyTrue;
 163:../cyfxbulksrcsink.c **** 
 164:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 165:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 166:../cyfxbulksrcsink.c ****     {
 167:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 168:../cyfxbulksrcsink.c ****     }
 169:../cyfxbulksrcsink.c **** 
 170:../cyfxbulksrcsink.c ****     /* Set the UART transfer to a really large value. */
 171:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 172:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 173:../cyfxbulksrcsink.c ****     {
 174:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 175:../cyfxbulksrcsink.c ****     }
 176:../cyfxbulksrcsink.c **** 
 177:../cyfxbulksrcsink.c ****     /* Initialize the debug module. */
 178:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 8);
 179:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 180:../cyfxbulksrcsink.c ****     {
 181:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 182:../cyfxbulksrcsink.c ****     }
 183:../cyfxbulksrcsink.c **** 
 184:../cyfxbulksrcsink.c ****     CyU3PDebugPreamble(CyFalse);
 185:../cyfxbulksrcsink.c **** }
 186:../cyfxbulksrcsink.c **** #endif
 187:../cyfxbulksrcsink.c **** 
 188:../cyfxbulksrcsink.c **** /* Callback funtion for the DMA event notification. */
 189:../cyfxbulksrcsink.c **** void
 190:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkDmaCallback (
 191:../cyfxbulksrcsink.c ****         CyU3PDmaChannel   *chHandle, /* Handle to the DMA channel. */
 192:../cyfxbulksrcsink.c ****         CyU3PDmaCbType_t  type,      /* Callback type.             */
 193:../cyfxbulksrcsink.c ****         CyU3PDmaCBInput_t *input)    /* Callback status.           */
 194:../cyfxbulksrcsink.c **** {
 270              		.loc 1 194 0
 271              		.cfi_startproc
 272              		@ args = 0, pretend = 0, frame = 32
 273              		@ frame_needed = 1, uses_anonymous_args = 0
 274 001c 00482DE9 		stmfd	sp!, {fp, lr}
 275              	.LCFI2:
 276              		.cfi_def_cfa_offset 8
 277 0020 04B08DE2 		add	fp, sp, #4
 278              		.cfi_offset 14, -4
 279              		.cfi_offset 11, -8
 280              	.LCFI3:
 281              		.cfi_def_cfa 11, 4
 282 0024 20D04DE2 		sub	sp, sp, #32
 283 0028 18000BE5 		str	r0, [fp, #-24]
 284 002c 0130A0E1 		mov	r3, r1
 285 0030 20200BE5 		str	r2, [fp, #-32]
 286 0034 BA314BE1 		strh	r3, [fp, #-26]	@ movhi
 195:../cyfxbulksrcsink.c ****     CyU3PDmaBuffer_t buf_p;
 196:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 287              		.loc 1 196 0
 288 0038 0030A0E3 		mov	r3, #0
 289 003c 08300BE5 		str	r3, [fp, #-8]
 197:../cyfxbulksrcsink.c **** 
 198:../cyfxbulksrcsink.c ****     glDataTransStarted = CyTrue;
 290              		.loc 1 198 0
 291 0040 E0309FE5 		ldr	r3, .L9
 292 0044 0120A0E3 		mov	r2, #1
 293 0048 002083E5 		str	r2, [r3, #0]
 199:../cyfxbulksrcsink.c **** 
 200:../cyfxbulksrcsink.c ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 294              		.loc 1 200 0
 295 004c BA315BE1 		ldrh	r3, [fp, #-26]
 296 0050 080053E3 		cmp	r3, #8
 297 0054 0E00001A 		bne	.L4
 201:../cyfxbulksrcsink.c ****     {
 202:../cyfxbulksrcsink.c ****         /* This is a produce event notification to the CPU. This notification is 
 203:../cyfxbulksrcsink.c ****          * received upon reception of every buffer. We have to discard the buffer
 204:../cyfxbulksrcsink.c ****          * as soon as it is received to implement the data sink. */
 205:../cyfxbulksrcsink.c ****         status = CyU3PDmaChannelDiscardBuffer (chHandle);
 298              		.loc 1 205 0
 299 0058 18001BE5 		ldr	r0, [fp, #-24]
 300 005c FEFFFFEB 		bl	CyU3PDmaChannelDiscardBuffer
 301 0060 08000BE5 		str	r0, [fp, #-8]
 206:../cyfxbulksrcsink.c ****         if (status != CY_U3P_SUCCESS)
 302              		.loc 1 206 0
 303 0064 08301BE5 		ldr	r3, [fp, #-8]
 304 0068 000053E3 		cmp	r3, #0
 305 006c 0300000A 		beq	.L5
 207:../cyfxbulksrcsink.c ****         {
 208:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "CyU3PDmaChannelDiscardBuffer failed, Error code = %d\n", status);
 306              		.loc 1 208 0
 307 0070 0400A0E3 		mov	r0, #4
 308 0074 B0109FE5 		ldr	r1, .L9+4
 309 0078 08201BE5 		ldr	r2, [fp, #-8]
 310 007c FEFFFFEB 		bl	CyU3PDebugPrint
 311              	.L5:
 209:../cyfxbulksrcsink.c ****         }
 210:../cyfxbulksrcsink.c **** 
 211:../cyfxbulksrcsink.c ****         /* Increment the counter. */
 212:../cyfxbulksrcsink.c ****         glDMARxCount++;
 312              		.loc 1 212 0
 313 0080 A8309FE5 		ldr	r3, .L9+8
 314 0084 003093E5 		ldr	r3, [r3, #0]
 315 0088 012083E2 		add	r2, r3, #1
 316 008c 9C309FE5 		ldr	r3, .L9+8
 317 0090 002083E5 		str	r2, [r3, #0]
 318              	.L4:
 213:../cyfxbulksrcsink.c ****     }
 214:../cyfxbulksrcsink.c ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 319              		.loc 1 214 0
 320 0094 BA315BE1 		ldrh	r3, [fp, #-26]
 321 0098 100053E3 		cmp	r3, #16
 322 009c 1F00001A 		bne	.L3
 215:../cyfxbulksrcsink.c ****     {
 216:../cyfxbulksrcsink.c ****         /* This is a consume event notification to the CPU. This notification is 
 217:../cyfxbulksrcsink.c ****          * received when a buffer is sent out from the device. We have to commit
 218:../cyfxbulksrcsink.c ****          * a new buffer as soon as a buffer is available to implement the data
 219:../cyfxbulksrcsink.c ****          * source. The data is preloaded into the buffer at that start. So just
 220:../cyfxbulksrcsink.c ****          * commit the buffer. */
 221:../cyfxbulksrcsink.c ****         status = CyU3PDmaChannelGetBuffer (chHandle, &buf_p, CYU3P_NO_WAIT);
 323              		.loc 1 221 0
 324 00a0 14304BE2 		sub	r3, fp, #20
 325 00a4 18001BE5 		ldr	r0, [fp, #-24]
 326 00a8 0310A0E1 		mov	r1, r3
 327 00ac 0020A0E3 		mov	r2, #0
 328 00b0 FEFFFFEB 		bl	CyU3PDmaChannelGetBuffer
 329 00b4 08000BE5 		str	r0, [fp, #-8]
 222:../cyfxbulksrcsink.c ****         if (status == CY_U3P_SUCCESS)
 330              		.loc 1 222 0
 331 00b8 08301BE5 		ldr	r3, [fp, #-8]
 332 00bc 000053E3 		cmp	r3, #0
 333 00c0 0D00001A 		bne	.L7
 223:../cyfxbulksrcsink.c ****         {
 224:../cyfxbulksrcsink.c ****             /* Commit the full buffer with default status. */
 225:../cyfxbulksrcsink.c ****             status = CyU3PDmaChannelCommitBuffer (chHandle, buf_p.size, 0);
 334              		.loc 1 225 0
 335 00c4 BE305BE1 		ldrh	r3, [fp, #-14]
 336 00c8 18001BE5 		ldr	r0, [fp, #-24]
 337 00cc 0310A0E1 		mov	r1, r3
 338 00d0 0020A0E3 		mov	r2, #0
 339 00d4 FEFFFFEB 		bl	CyU3PDmaChannelCommitBuffer
 340 00d8 08000BE5 		str	r0, [fp, #-8]
 226:../cyfxbulksrcsink.c ****             if (status != CY_U3P_SUCCESS)
 341              		.loc 1 226 0
 342 00dc 08301BE5 		ldr	r3, [fp, #-8]
 343 00e0 000053E3 		cmp	r3, #0
 344 00e4 0800000A 		beq	.L8
 227:../cyfxbulksrcsink.c ****             {
 228:../cyfxbulksrcsink.c ****                 CyU3PDebugPrint (4, "CyU3PDmaChannelCommitBuffer failed, Error code = %d\n", status
 345              		.loc 1 228 0
 346 00e8 0400A0E3 		mov	r0, #4
 347 00ec 40109FE5 		ldr	r1, .L9+12
 348 00f0 08201BE5 		ldr	r2, [fp, #-8]
 349 00f4 FEFFFFEB 		bl	CyU3PDebugPrint
 350 00f8 030000EA 		b	.L8
 351              	.L7:
 229:../cyfxbulksrcsink.c ****             }
 230:../cyfxbulksrcsink.c ****         }
 231:../cyfxbulksrcsink.c ****         else
 232:../cyfxbulksrcsink.c ****         {
 233:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "CyU3PDmaChannelGetBuffer failed, Error code = %d\n", status);
 352              		.loc 1 233 0
 353 00fc 0400A0E3 		mov	r0, #4
 354 0100 30109FE5 		ldr	r1, .L9+16
 355 0104 08201BE5 		ldr	r2, [fp, #-8]
 356 0108 FEFFFFEB 		bl	CyU3PDebugPrint
 357              	.L8:
 234:../cyfxbulksrcsink.c ****         }
 235:../cyfxbulksrcsink.c **** 
 236:../cyfxbulksrcsink.c ****         /* Increment the counter. */
 237:../cyfxbulksrcsink.c ****         glDMATxCount++;
 358              		.loc 1 237 0
 359 010c 28309FE5 		ldr	r3, .L9+20
 360 0110 003093E5 		ldr	r3, [r3, #0]
 361 0114 012083E2 		add	r2, r3, #1
 362 0118 1C309FE5 		ldr	r3, .L9+20
 363 011c 002083E5 		str	r2, [r3, #0]
 364              	.L3:
 238:../cyfxbulksrcsink.c ****     }
 239:../cyfxbulksrcsink.c **** }
 365              		.loc 1 239 0
 366 0120 04D04BE2 		sub	sp, fp, #4
 367 0124 0088BDE8 		ldmfd	sp!, {fp, pc}
 368              	.L10:
 369              		.align	2
 370              	.L9:
 371 0128 00000000 		.word	glDataTransStarted
 372 012c 1C000000 		.word	.LC0
 373 0130 00000000 		.word	glDMARxCount
 374 0134 54000000 		.word	.LC1
 375 0138 8C000000 		.word	.LC2
 376 013c 00000000 		.word	glDMATxCount
 377              		.cfi_endproc
 378              	.LFE1:
 380              		.section	.rodata
 381 00be 0000     		.align	2
 382              	.LC3:
 383 00c0 4572726F 		.ascii	"Error! Invalid USB speed.\012\000"
 383      72212049 
 383      6E76616C 
 383      69642055 
 383      53422073 
 384 00db 00       		.align	2
 385              	.LC4:
 386 00dc 43795533 		.ascii	"CyU3PSetEpConfig failed, Error code = %d\012\000"
 386      50536574 
 386      4570436F 
 386      6E666967 
 386      20666169 
 387 0106 0000     		.align	2
 388              	.LC5:
 389 0108 43795533 		.ascii	"CyU3PDmaChannelCreate failed, Error code = %d\012\000"
 389      50446D61 
 389      4368616E 
 389      6E656C43 
 389      72656174 
 390 0137 00       		.align	2
 391              	.LC6:
 392 0138 43795533 		.ascii	"CyU3PDmaChannelSetXfer failed, Error code = %d\012\000"
 392      50446D61 
 392      4368616E 
 392      6E656C53 
 392      65745866 
 393              		.text
 394              		.align	2
 395              		.global	CyFxBulkSrcSinkApplnStart
 397              	CyFxBulkSrcSinkApplnStart:
 398              	.LFB2:
 240:../cyfxbulksrcsink.c **** 
 241:../cyfxbulksrcsink.c **** /* This function starts the application. This is called
 242:../cyfxbulksrcsink.c ****  * when a SET_CONF event is received from the USB host. The endpoints
 243:../cyfxbulksrcsink.c ****  * are configured and the DMA pipe is setup in this function. */
 244:../cyfxbulksrcsink.c **** void
 245:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnStart (
 246:../cyfxbulksrcsink.c ****         void)
 247:../cyfxbulksrcsink.c **** {
 399              		.loc 1 247 0
 400              		.cfi_startproc
 401              		@ args = 0, pretend = 0, frame = 64
 402              		@ frame_needed = 1, uses_anonymous_args = 0
 403 0140 00482DE9 		stmfd	sp!, {fp, lr}
 404              	.LCFI4:
 405              		.cfi_def_cfa_offset 8
 406 0144 04B08DE2 		add	fp, sp, #4
 407              		.cfi_offset 14, -4
 408              		.cfi_offset 11, -8
 409              	.LCFI5:
 410              		.cfi_def_cfa 11, 4
 411 0148 40D04DE2 		sub	sp, sp, #64
 248:../cyfxbulksrcsink.c ****     uint16_t size = 0, index = 0;
 412              		.loc 1 248 0
 413 014c 0030A0E3 		mov	r3, #0
 414 0150 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 415 0154 0030A0E3 		mov	r3, #0
 416 0158 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 249:../cyfxbulksrcsink.c ****     CyU3PEpConfig_t epCfg;
 250:../cyfxbulksrcsink.c ****     CyU3PDmaBuffer_t buf_p;
 251:../cyfxbulksrcsink.c ****     CyU3PDmaChannelConfig_t dmaCfg;
 252:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 417              		.loc 1 252 0
 418 015c 0030A0E3 		mov	r3, #0
 419 0160 0C300BE5 		str	r3, [fp, #-12]
 253:../cyfxbulksrcsink.c ****     CyU3PUSBSpeed_t usbSpeed = CyU3PUsbGetSpeed();
 420              		.loc 1 253 0
 421 0164 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 422 0168 0030A0E1 		mov	r3, r0
 423 016c 0D304BE5 		strb	r3, [fp, #-13]
 254:../cyfxbulksrcsink.c **** 
 255:../cyfxbulksrcsink.c ****     /* First identify the usb speed. Once that is identified,
 256:../cyfxbulksrcsink.c ****      * create a DMA channel and start the transfer on this. */
 257:../cyfxbulksrcsink.c **** 
 258:../cyfxbulksrcsink.c ****     /* Based on the Bus Speed configure the endpoint packet size */
 259:../cyfxbulksrcsink.c ****     switch (usbSpeed)
 424              		.loc 1 259 0
 425 0170 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 426 0174 020053E3 		cmp	r3, #2
 427 0178 0600000A 		beq	.L14
 428 017c 030053E3 		cmp	r3, #3
 429 0180 0700000A 		beq	.L15
 430 0184 010053E3 		cmp	r3, #1
 431 0188 0800001A 		bne	.L29
 432              	.L13:
 260:../cyfxbulksrcsink.c ****     {
 261:../cyfxbulksrcsink.c ****     case CY_U3P_FULL_SPEED:
 262:../cyfxbulksrcsink.c ****         size = 64;
 433              		.loc 1 262 0
 434 018c 4030A0E3 		mov	r3, #64
 435 0190 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 263:../cyfxbulksrcsink.c ****         break;
 436              		.loc 1 263 0
 437 0194 0B0000EA 		b	.L16
 438              	.L14:
 264:../cyfxbulksrcsink.c **** 
 265:../cyfxbulksrcsink.c ****     case CY_U3P_HIGH_SPEED:
 266:../cyfxbulksrcsink.c ****         size = 512;
 439              		.loc 1 266 0
 440 0198 023CA0E3 		mov	r3, #512
 441 019c B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 267:../cyfxbulksrcsink.c ****         break;
 442              		.loc 1 267 0
 443 01a0 080000EA 		b	.L16
 444              	.L15:
 268:../cyfxbulksrcsink.c **** 
 269:../cyfxbulksrcsink.c ****     case  CY_U3P_SUPER_SPEED:
 270:../cyfxbulksrcsink.c ****         size = 1024;
 445              		.loc 1 270 0
 446 01a4 013BA0E3 		mov	r3, #1024
 447 01a8 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 271:../cyfxbulksrcsink.c ****         break;
 448              		.loc 1 271 0
 449 01ac 050000EA 		b	.L16
 450              	.L29:
 272:../cyfxbulksrcsink.c **** 
 273:../cyfxbulksrcsink.c ****     default:
 274:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "Error! Invalid USB speed.\n");
 451              		.loc 1 274 0
 452 01b0 0400A0E3 		mov	r0, #4
 453 01b4 28139FE5 		ldr	r1, .L30
 454 01b8 FEFFFFEB 		bl	CyU3PDebugPrint
 275:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (CY_U3P_ERROR_FAILURE);
 455              		.loc 1 275 0
 456 01bc 4A00A0E3 		mov	r0, #74
 457 01c0 FEFFFFEB 		bl	CyFxAppErrorHandler
 276:../cyfxbulksrcsink.c ****         break;
 458              		.loc 1 276 0
 459 01c4 0000A0E1 		mov	r0, r0	@ nop
 460              	.L16:
 277:../cyfxbulksrcsink.c ****     }
 278:../cyfxbulksrcsink.c **** 
 279:../cyfxbulksrcsink.c ****     CyU3PMemSet ((uint8_t *)&epCfg, 0, sizeof (epCfg));
 461              		.loc 1 279 0
 462 01c8 1C304BE2 		sub	r3, fp, #28
 463 01cc 0300A0E1 		mov	r0, r3
 464 01d0 0010A0E3 		mov	r1, #0
 465 01d4 0C20A0E3 		mov	r2, #12
 466 01d8 FEFFFFEB 		bl	CyU3PMemSet
 280:../cyfxbulksrcsink.c ****     epCfg.enable = CyTrue;
 467              		.loc 1 280 0
 468 01dc 0130A0E3 		mov	r3, #1
 469 01e0 1C300BE5 		str	r3, [fp, #-28]
 281:../cyfxbulksrcsink.c ****     epCfg.epType = CY_U3P_USB_EP_BULK;
 470              		.loc 1 281 0
 471 01e4 0230A0E3 		mov	r3, #2
 472 01e8 18304BE5 		strb	r3, [fp, #-24]
 282:../cyfxbulksrcsink.c ****     epCfg.burstLen = (usbSpeed == CY_U3P_SUPER_SPEED) ?
 473              		.loc 1 282 0
 474 01ec 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 475 01f0 030053E3 		cmp	r3, #3
 476 01f4 0100001A 		bne	.L17
 477              		.loc 1 282 0 is_stmt 0 discriminator 1
 478 01f8 0830A0E3 		mov	r3, #8
 479 01fc 000000EA 		b	.L18
 480              	.L17:
 481              		.loc 1 282 0 discriminator 2
 482 0200 0130A0E3 		mov	r3, #1
 483              	.L18:
 484              		.loc 1 282 0 discriminator 3
 485 0204 12304BE5 		strb	r3, [fp, #-18]
 283:../cyfxbulksrcsink.c ****         (CY_FX_EP_BURST_LENGTH) : 1;
 284:../cyfxbulksrcsink.c ****     epCfg.streams = 0;
 486              		.loc 1 284 0 is_stmt 1 discriminator 3
 487 0208 0030A0E3 		mov	r3, #0
 488 020c B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 285:../cyfxbulksrcsink.c ****     epCfg.pcktSize = size;
 489              		.loc 1 285 0 discriminator 3
 490 0210 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 491 0214 B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 286:../cyfxbulksrcsink.c **** 
 287:../cyfxbulksrcsink.c ****     /* Producer endpoint configuration */
 288:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_PRODUCER, &epCfg);
 492              		.loc 1 288 0 discriminator 3
 493 0218 1C304BE2 		sub	r3, fp, #28
 494 021c 0100A0E3 		mov	r0, #1
 495 0220 0310A0E1 		mov	r1, r3
 496 0224 FEFFFFEB 		bl	CyU3PSetEpConfig
 497 0228 0C000BE5 		str	r0, [fp, #-12]
 289:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 498              		.loc 1 289 0 discriminator 3
 499 022c 0C301BE5 		ldr	r3, [fp, #-12]
 500 0230 000053E3 		cmp	r3, #0
 501 0234 0500000A 		beq	.L19
 290:../cyfxbulksrcsink.c ****     {
 291:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 502              		.loc 1 291 0
 503 0238 0400A0E3 		mov	r0, #4
 504 023c A4129FE5 		ldr	r1, .L30+4
 505 0240 0C201BE5 		ldr	r2, [fp, #-12]
 506 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 292:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (apiRetStatus);
 507              		.loc 1 292 0
 508 0248 0C001BE5 		ldr	r0, [fp, #-12]
 509 024c FEFFFFEB 		bl	CyFxAppErrorHandler
 510              	.L19:
 293:../cyfxbulksrcsink.c ****     }
 294:../cyfxbulksrcsink.c **** 
 295:../cyfxbulksrcsink.c ****     /* Consumer endpoint configuration */
 296:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_CONSUMER, &epCfg);
 511              		.loc 1 296 0
 512 0250 1C304BE2 		sub	r3, fp, #28
 513 0254 8100A0E3 		mov	r0, #129
 514 0258 0310A0E1 		mov	r1, r3
 515 025c FEFFFFEB 		bl	CyU3PSetEpConfig
 516 0260 0C000BE5 		str	r0, [fp, #-12]
 297:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 517              		.loc 1 297 0
 518 0264 0C301BE5 		ldr	r3, [fp, #-12]
 519 0268 000053E3 		cmp	r3, #0
 520 026c 0500000A 		beq	.L20
 298:../cyfxbulksrcsink.c ****     {
 299:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 521              		.loc 1 299 0
 522 0270 0400A0E3 		mov	r0, #4
 523 0274 6C129FE5 		ldr	r1, .L30+4
 524 0278 0C201BE5 		ldr	r2, [fp, #-12]
 525 027c FEFFFFEB 		bl	CyU3PDebugPrint
 300:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (apiRetStatus);
 526              		.loc 1 300 0
 527 0280 0C001BE5 		ldr	r0, [fp, #-12]
 528 0284 FEFFFFEB 		bl	CyFxAppErrorHandler
 529              	.L20:
 301:../cyfxbulksrcsink.c ****     }
 302:../cyfxbulksrcsink.c **** 
 303:../cyfxbulksrcsink.c ****     /* Flush the endpoint memory */
 304:../cyfxbulksrcsink.c ****     CyU3PUsbFlushEp(CY_FX_EP_PRODUCER);
 530              		.loc 1 304 0
 531 0288 0100A0E3 		mov	r0, #1
 532 028c FEFFFFEB 		bl	CyU3PUsbFlushEp
 305:../cyfxbulksrcsink.c ****     CyU3PUsbFlushEp(CY_FX_EP_CONSUMER);
 533              		.loc 1 305 0
 534 0290 8100A0E3 		mov	r0, #129
 535 0294 FEFFFFEB 		bl	CyU3PUsbFlushEp
 306:../cyfxbulksrcsink.c **** 
 307:../cyfxbulksrcsink.c ****     /* Create a DMA MANUAL_IN channel for the producer socket. */
 308:../cyfxbulksrcsink.c ****     CyU3PMemSet ((uint8_t *)&dmaCfg, 0, sizeof (dmaCfg));
 536              		.loc 1 308 0
 537 0298 44304BE2 		sub	r3, fp, #68
 538 029c 0300A0E1 		mov	r0, r3
 539 02a0 0010A0E3 		mov	r1, #0
 540 02a4 1C20A0E3 		mov	r2, #28
 541 02a8 FEFFFFEB 		bl	CyU3PMemSet
 309:../cyfxbulksrcsink.c ****     /* The buffer size will be same as packet size for the
 310:../cyfxbulksrcsink.c ****      * full speed, high speed and super speed non-burst modes.
 311:../cyfxbulksrcsink.c ****      * For super speed burst mode of operation, the buffers will be
 312:../cyfxbulksrcsink.c ****      * 1024 * burst length so that a full burst can be completed.
 313:../cyfxbulksrcsink.c ****      * This will mean that a buffer will be available only after it
 314:../cyfxbulksrcsink.c ****      * has been filled or when a short packet is received. */
 315:../cyfxbulksrcsink.c ****     dmaCfg.size  = (size * CY_FX_EP_BURST_LENGTH);
 542              		.loc 1 315 0
 543 02ac B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 544 02b0 8331A0E1 		mov	r3, r3, asl #3
 545 02b4 0338A0E1 		mov	r3, r3, asl #16
 546 02b8 2338A0E1 		mov	r3, r3, lsr #16
 547 02bc B4344BE1 		strh	r3, [fp, #-68]	@ movhi
 316:../cyfxbulksrcsink.c ****     /* Multiply the buffer size with the multiplier
 317:../cyfxbulksrcsink.c ****      * for performance improvement. */
 318:../cyfxbulksrcsink.c ****     dmaCfg.size *= CY_FX_DMA_SIZE_MULTIPLIER;
 548              		.loc 1 318 0
 549 02c0 B4345BE1 		ldrh	r3, [fp, #-68]
 550 02c4 8330A0E1 		mov	r3, r3, asl #1
 551 02c8 0338A0E1 		mov	r3, r3, asl #16
 552 02cc 2338A0E1 		mov	r3, r3, lsr #16
 553 02d0 B4344BE1 		strh	r3, [fp, #-68]	@ movhi
 319:../cyfxbulksrcsink.c ****     dmaCfg.count = CY_FX_BULKSRCSINK_DMA_BUF_COUNT;
 554              		.loc 1 319 0
 555 02d4 0430A0E3 		mov	r3, #4
 556 02d8 B2344BE1 		strh	r3, [fp, #-66]	@ movhi
 320:../cyfxbulksrcsink.c ****     dmaCfg.prodSckId = CY_FX_EP_PRODUCER_SOCKET;
 557              		.loc 1 320 0
 558 02dc 08329FE5 		ldr	r3, .L30+8
 559 02e0 B0344BE1 		strh	r3, [fp, #-64]	@ movhi
 321:../cyfxbulksrcsink.c ****     dmaCfg.consSckId = CY_U3P_CPU_SOCKET_CONS;
 560              		.loc 1 321 0
 561 02e4 3F3CA0E3 		mov	r3, #16128
 562 02e8 BE334BE1 		strh	r3, [fp, #-62]	@ movhi
 322:../cyfxbulksrcsink.c ****     dmaCfg.dmaMode = CY_U3P_DMA_MODE_BYTE;
 563              		.loc 1 322 0
 564 02ec 0030A0E3 		mov	r3, #0
 565 02f0 34304BE5 		strb	r3, [fp, #-52]
 323:../cyfxbulksrcsink.c ****     dmaCfg.notification = CY_U3P_DMA_CB_PROD_EVENT;
 566              		.loc 1 323 0
 567 02f4 0830A0E3 		mov	r3, #8
 568 02f8 30300BE5 		str	r3, [fp, #-48]
 324:../cyfxbulksrcsink.c ****     dmaCfg.cb = CyFxBulkSrcSinkDmaCallback;
 569              		.loc 1 324 0
 570 02fc EC319FE5 		ldr	r3, .L30+12
 571 0300 2C300BE5 		str	r3, [fp, #-44]
 325:../cyfxbulksrcsink.c ****     dmaCfg.prodHeader = 0;
 572              		.loc 1 325 0
 573 0304 0030A0E3 		mov	r3, #0
 574 0308 BA334BE1 		strh	r3, [fp, #-58]	@ movhi
 326:../cyfxbulksrcsink.c ****     dmaCfg.prodFooter = 0;
 575              		.loc 1 326 0
 576 030c 0030A0E3 		mov	r3, #0
 577 0310 B8334BE1 		strh	r3, [fp, #-56]	@ movhi
 327:../cyfxbulksrcsink.c ****     dmaCfg.consHeader = 0;
 578              		.loc 1 327 0
 579 0314 0030A0E3 		mov	r3, #0
 580 0318 B6334BE1 		strh	r3, [fp, #-54]	@ movhi
 328:../cyfxbulksrcsink.c ****     dmaCfg.prodAvailCount = 0;
 581              		.loc 1 328 0
 582 031c 0030A0E3 		mov	r3, #0
 583 0320 BC334BE1 		strh	r3, [fp, #-60]	@ movhi
 329:../cyfxbulksrcsink.c **** 
 330:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleBulkSink,
 584              		.loc 1 330 0
 585 0324 44304BE2 		sub	r3, fp, #68
 586 0328 C4019FE5 		ldr	r0, .L30+16
 587 032c 0310A0E3 		mov	r1, #3
 588 0330 0320A0E1 		mov	r2, r3
 589 0334 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 590 0338 0C000BE5 		str	r0, [fp, #-12]
 331:../cyfxbulksrcsink.c ****             CY_U3P_DMA_TYPE_MANUAL_IN, &dmaCfg);
 332:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 591              		.loc 1 332 0
 592 033c 0C301BE5 		ldr	r3, [fp, #-12]
 593 0340 000053E3 		cmp	r3, #0
 594 0344 0500000A 		beq	.L21
 333:../cyfxbulksrcsink.c ****     {
 334:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PDmaChannelCreate failed, Error code = %d\n", apiRetStatus);
 595              		.loc 1 334 0
 596 0348 0400A0E3 		mov	r0, #4
 597 034c A4119FE5 		ldr	r1, .L30+20
 598 0350 0C201BE5 		ldr	r2, [fp, #-12]
 599 0354 FEFFFFEB 		bl	CyU3PDebugPrint
 335:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 600              		.loc 1 335 0
 601 0358 0C001BE5 		ldr	r0, [fp, #-12]
 602 035c FEFFFFEB 		bl	CyFxAppErrorHandler
 603              	.L21:
 336:../cyfxbulksrcsink.c ****     }
 337:../cyfxbulksrcsink.c **** 
 338:../cyfxbulksrcsink.c ****     /* Create a DMA MANUAL_OUT channel for the consumer socket. */
 339:../cyfxbulksrcsink.c ****     dmaCfg.notification = CY_U3P_DMA_CB_CONS_EVENT;
 604              		.loc 1 339 0
 605 0360 1030A0E3 		mov	r3, #16
 606 0364 30300BE5 		str	r3, [fp, #-48]
 340:../cyfxbulksrcsink.c ****     dmaCfg.prodSckId = CY_U3P_CPU_SOCKET_PROD;
 607              		.loc 1 340 0
 608 0368 8C319FE5 		ldr	r3, .L30+24
 609 036c B0344BE1 		strh	r3, [fp, #-64]	@ movhi
 341:../cyfxbulksrcsink.c ****     dmaCfg.consSckId = CY_FX_EP_CONSUMER_SOCKET;
 610              		.loc 1 341 0
 611 0370 88319FE5 		ldr	r3, .L30+28
 612 0374 BE334BE1 		strh	r3, [fp, #-62]	@ movhi
 342:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleBulkSrc,
 613              		.loc 1 342 0
 614 0378 44304BE2 		sub	r3, fp, #68
 615 037c 80019FE5 		ldr	r0, .L30+32
 616 0380 0410A0E3 		mov	r1, #4
 617 0384 0320A0E1 		mov	r2, r3
 618 0388 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 619 038c 0C000BE5 		str	r0, [fp, #-12]
 343:../cyfxbulksrcsink.c ****             CY_U3P_DMA_TYPE_MANUAL_OUT, &dmaCfg);
 344:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 620              		.loc 1 344 0
 621 0390 0C301BE5 		ldr	r3, [fp, #-12]
 622 0394 000053E3 		cmp	r3, #0
 623 0398 0500000A 		beq	.L22
 345:../cyfxbulksrcsink.c ****     {
 346:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PDmaChannelCreate failed, Error code = %d\n", apiRetStatus);
 624              		.loc 1 346 0
 625 039c 0400A0E3 		mov	r0, #4
 626 03a0 50119FE5 		ldr	r1, .L30+20
 627 03a4 0C201BE5 		ldr	r2, [fp, #-12]
 628 03a8 FEFFFFEB 		bl	CyU3PDebugPrint
 347:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 629              		.loc 1 347 0
 630 03ac 0C001BE5 		ldr	r0, [fp, #-12]
 631 03b0 FEFFFFEB 		bl	CyFxAppErrorHandler
 632              	.L22:
 348:../cyfxbulksrcsink.c ****     }
 349:../cyfxbulksrcsink.c **** 
 350:../cyfxbulksrcsink.c ****     /* Set DMA Channel transfer size */
 351:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glChHandleBulkSink, CY_FX_BULKSRCSINK_DMA_TX_SIZE);
 633              		.loc 1 351 0
 634 03b4 38019FE5 		ldr	r0, .L30+16
 635 03b8 0010A0E3 		mov	r1, #0
 636 03bc FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 637 03c0 0C000BE5 		str	r0, [fp, #-12]
 352:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 638              		.loc 1 352 0
 639 03c4 0C301BE5 		ldr	r3, [fp, #-12]
 640 03c8 000053E3 		cmp	r3, #0
 641 03cc 0500000A 		beq	.L23
 353:../cyfxbulksrcsink.c ****     {
 354:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PDmaChannelSetXfer failed, Error code = %d\n", apiRetStatus);
 642              		.loc 1 354 0
 643 03d0 0400A0E3 		mov	r0, #4
 644 03d4 2C119FE5 		ldr	r1, .L30+36
 645 03d8 0C201BE5 		ldr	r2, [fp, #-12]
 646 03dc FEFFFFEB 		bl	CyU3PDebugPrint
 355:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 647              		.loc 1 355 0
 648 03e0 0C001BE5 		ldr	r0, [fp, #-12]
 649 03e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 650              	.L23:
 356:../cyfxbulksrcsink.c ****     }
 357:../cyfxbulksrcsink.c **** 
 358:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glChHandleBulkSrc, CY_FX_BULKSRCSINK_DMA_TX_SIZE);
 651              		.loc 1 358 0
 652 03e8 14019FE5 		ldr	r0, .L30+32
 653 03ec 0010A0E3 		mov	r1, #0
 654 03f0 FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 655 03f4 0C000BE5 		str	r0, [fp, #-12]
 359:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 656              		.loc 1 359 0
 657 03f8 0C301BE5 		ldr	r3, [fp, #-12]
 658 03fc 000053E3 		cmp	r3, #0
 659 0400 0500000A 		beq	.L24
 360:../cyfxbulksrcsink.c ****     {
 361:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PDmaChannelSetXfer failed, Error code = %d\n", apiRetStatus);
 660              		.loc 1 361 0
 661 0404 0400A0E3 		mov	r0, #4
 662 0408 F8109FE5 		ldr	r1, .L30+36
 663 040c 0C201BE5 		ldr	r2, [fp, #-12]
 664 0410 FEFFFFEB 		bl	CyU3PDebugPrint
 362:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 665              		.loc 1 362 0
 666 0414 0C001BE5 		ldr	r0, [fp, #-12]
 667 0418 FEFFFFEB 		bl	CyFxAppErrorHandler
 668              	.L24:
 363:../cyfxbulksrcsink.c ****     }
 364:../cyfxbulksrcsink.c **** 
 365:../cyfxbulksrcsink.c ****     /* Now preload all buffers in the MANUAL_OUT pipe with the required data. */
 366:../cyfxbulksrcsink.c ****     for (index = 0; index < CY_FX_BULKSRCSINK_DMA_BUF_COUNT; index++)
 669              		.loc 1 366 0
 670 041c 0030A0E3 		mov	r3, #0
 671 0420 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 672 0424 260000EA 		b	.L25
 673              	.L28:
 367:../cyfxbulksrcsink.c ****     {
 368:../cyfxbulksrcsink.c ****         apiRetStatus = CyU3PDmaChannelGetBuffer (&glChHandleBulkSrc, &buf_p, CYU3P_NO_WAIT);
 674              		.loc 1 368 0
 675 0428 28304BE2 		sub	r3, fp, #40
 676 042c D0009FE5 		ldr	r0, .L30+32
 677 0430 0310A0E1 		mov	r1, r3
 678 0434 0020A0E3 		mov	r2, #0
 679 0438 FEFFFFEB 		bl	CyU3PDmaChannelGetBuffer
 680 043c 0C000BE5 		str	r0, [fp, #-12]
 369:../cyfxbulksrcsink.c ****         if (apiRetStatus != CY_U3P_SUCCESS)
 681              		.loc 1 369 0
 682 0440 0C301BE5 		ldr	r3, [fp, #-12]
 683 0444 000053E3 		cmp	r3, #0
 684 0448 0500000A 		beq	.L26
 370:../cyfxbulksrcsink.c ****         {
 371:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "CyU3PDmaChannelGetBuffer failed, Error code = %d\n", apiRetStatus)
 685              		.loc 1 371 0
 686 044c 0400A0E3 		mov	r0, #4
 687 0450 B4109FE5 		ldr	r1, .L30+40
 688 0454 0C201BE5 		ldr	r2, [fp, #-12]
 689 0458 FEFFFFEB 		bl	CyU3PDebugPrint
 372:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler(apiRetStatus);
 690              		.loc 1 372 0
 691 045c 0C001BE5 		ldr	r0, [fp, #-12]
 692 0460 FEFFFFEB 		bl	CyFxAppErrorHandler
 693              	.L26:
 373:../cyfxbulksrcsink.c ****         }
 374:../cyfxbulksrcsink.c ****         CyU3PMemSet (buf_p.buffer, CY_FX_BULKSRCSINK_PATTERN, buf_p.size);
 694              		.loc 1 374 0
 695 0464 28201BE5 		ldr	r2, [fp, #-40]
 696 0468 B2325BE1 		ldrh	r3, [fp, #-34]
 697 046c 0200A0E1 		mov	r0, r2
 698 0470 AA10A0E3 		mov	r1, #170
 699 0474 0320A0E1 		mov	r2, r3
 700 0478 FEFFFFEB 		bl	CyU3PMemSet
 375:../cyfxbulksrcsink.c ****         apiRetStatus = CyU3PDmaChannelCommitBuffer (&glChHandleBulkSrc, buf_p.size, 0);
 701              		.loc 1 375 0
 702 047c B2325BE1 		ldrh	r3, [fp, #-34]
 703 0480 7C009FE5 		ldr	r0, .L30+32
 704 0484 0310A0E1 		mov	r1, r3
 705 0488 0020A0E3 		mov	r2, #0
 706 048c FEFFFFEB 		bl	CyU3PDmaChannelCommitBuffer
 707 0490 0C000BE5 		str	r0, [fp, #-12]
 376:../cyfxbulksrcsink.c ****         if (apiRetStatus != CY_U3P_SUCCESS)
 708              		.loc 1 376 0
 709 0494 0C301BE5 		ldr	r3, [fp, #-12]
 710 0498 000053E3 		cmp	r3, #0
 711 049c 0500000A 		beq	.L27
 377:../cyfxbulksrcsink.c ****         {
 378:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "CyU3PDmaChannelCommitBuffer failed, Error code = %d\n", apiRetStat
 712              		.loc 1 378 0
 713 04a0 0400A0E3 		mov	r0, #4
 714 04a4 64109FE5 		ldr	r1, .L30+44
 715 04a8 0C201BE5 		ldr	r2, [fp, #-12]
 716 04ac FEFFFFEB 		bl	CyU3PDebugPrint
 379:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler(apiRetStatus);
 717              		.loc 1 379 0
 718 04b0 0C001BE5 		ldr	r0, [fp, #-12]
 719 04b4 FEFFFFEB 		bl	CyFxAppErrorHandler
 720              	.L27:
 366:../cyfxbulksrcsink.c ****     for (index = 0; index < CY_FX_BULKSRCSINK_DMA_BUF_COUNT; index++)
 721              		.loc 1 366 0
 722 04b8 B8305BE1 		ldrh	r3, [fp, #-8]	@ movhi
 723 04bc 013083E2 		add	r3, r3, #1
 724 04c0 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 725              	.L25:
 366:../cyfxbulksrcsink.c ****     for (index = 0; index < CY_FX_BULKSRCSINK_DMA_BUF_COUNT; index++)
 726              		.loc 1 366 0 is_stmt 0 discriminator 1
 727 04c4 B8305BE1 		ldrh	r3, [fp, #-8]
 728 04c8 030053E3 		cmp	r3, #3
 729 04cc D5FFFF9A 		bls	.L28
 380:../cyfxbulksrcsink.c ****         }
 381:../cyfxbulksrcsink.c ****     }
 382:../cyfxbulksrcsink.c **** 
 383:../cyfxbulksrcsink.c ****     /* Update the flag so that the application thread is notified of this. */
 384:../cyfxbulksrcsink.c ****     glIsApplnActive = CyTrue;
 730              		.loc 1 384 0 is_stmt 1
 731 04d0 3C309FE5 		ldr	r3, .L30+48
 732 04d4 0120A0E3 		mov	r2, #1
 733 04d8 002083E5 		str	r2, [r3, #0]
 385:../cyfxbulksrcsink.c **** }
 734              		.loc 1 385 0
 735 04dc 04D04BE2 		sub	sp, fp, #4
 736 04e0 0088BDE8 		ldmfd	sp!, {fp, pc}
 737              	.L31:
 738              		.align	2
 739              	.L30:
 740 04e4 C0000000 		.word	.LC3
 741 04e8 DC000000 		.word	.LC4
 742 04ec 01040000 		.word	1025
 743 04f0 00000000 		.word	CyFxBulkSrcSinkDmaCallback
 744 04f4 00000000 		.word	glChHandleBulkSink
 745 04f8 08010000 		.word	.LC5
 746 04fc 013F0000 		.word	16129
 747 0500 01030000 		.word	769
 748 0504 00000000 		.word	glChHandleBulkSrc
 749 0508 38010000 		.word	.LC6
 750 050c 8C000000 		.word	.LC2
 751 0510 54000000 		.word	.LC1
 752 0514 00000000 		.word	glIsApplnActive
 753              		.cfi_endproc
 754              	.LFE2:
 756              		.align	2
 757              		.global	CyFxBulkSrcSinkApplnStop
 759              	CyFxBulkSrcSinkApplnStop:
 760              	.LFB3:
 386:../cyfxbulksrcsink.c **** 
 387:../cyfxbulksrcsink.c **** /* This function stops the application. This shall be called whenever a RESET
 388:../cyfxbulksrcsink.c ****  * or DISCONNECT event is received from the USB host. The endpoints are
 389:../cyfxbulksrcsink.c ****  * disabled and the DMA pipe is destroyed by this function. */
 390:../cyfxbulksrcsink.c **** void
 391:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnStop (
 392:../cyfxbulksrcsink.c ****         void)
 393:../cyfxbulksrcsink.c **** {
 761              		.loc 1 393 0
 762              		.cfi_startproc
 763              		@ args = 0, pretend = 0, frame = 16
 764              		@ frame_needed = 1, uses_anonymous_args = 0
 765 0518 00482DE9 		stmfd	sp!, {fp, lr}
 766              	.LCFI6:
 767              		.cfi_def_cfa_offset 8
 768 051c 04B08DE2 		add	fp, sp, #4
 769              		.cfi_offset 14, -4
 770              		.cfi_offset 11, -8
 771              	.LCFI7:
 772              		.cfi_def_cfa 11, 4
 773 0520 10D04DE2 		sub	sp, sp, #16
 394:../cyfxbulksrcsink.c ****     CyU3PEpConfig_t epCfg;
 395:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 774              		.loc 1 395 0
 775 0524 0030A0E3 		mov	r3, #0
 776 0528 08300BE5 		str	r3, [fp, #-8]
 396:../cyfxbulksrcsink.c **** 
 397:../cyfxbulksrcsink.c ****     /* Update the flag so that the application thread is notified of this. */
 398:../cyfxbulksrcsink.c ****     glIsApplnActive = CyFalse;
 777              		.loc 1 398 0
 778 052c B8309FE5 		ldr	r3, .L35
 779 0530 0020A0E3 		mov	r2, #0
 780 0534 002083E5 		str	r2, [r3, #0]
 399:../cyfxbulksrcsink.c **** 
 400:../cyfxbulksrcsink.c ****     /* Destroy the channels */
 401:../cyfxbulksrcsink.c ****     CyU3PDmaChannelDestroy (&glChHandleBulkSink);
 781              		.loc 1 401 0
 782 0538 B0009FE5 		ldr	r0, .L35+4
 783 053c FEFFFFEB 		bl	CyU3PDmaChannelDestroy
 402:../cyfxbulksrcsink.c ****     CyU3PDmaChannelDestroy (&glChHandleBulkSrc);
 784              		.loc 1 402 0
 785 0540 AC009FE5 		ldr	r0, .L35+8
 786 0544 FEFFFFEB 		bl	CyU3PDmaChannelDestroy
 403:../cyfxbulksrcsink.c **** 
 404:../cyfxbulksrcsink.c ****     /* Flush the endpoint memory */
 405:../cyfxbulksrcsink.c ****     CyU3PUsbFlushEp(CY_FX_EP_PRODUCER);
 787              		.loc 1 405 0
 788 0548 0100A0E3 		mov	r0, #1
 789 054c FEFFFFEB 		bl	CyU3PUsbFlushEp
 406:../cyfxbulksrcsink.c ****     CyU3PUsbFlushEp(CY_FX_EP_CONSUMER);
 790              		.loc 1 406 0
 791 0550 8100A0E3 		mov	r0, #129
 792 0554 FEFFFFEB 		bl	CyU3PUsbFlushEp
 407:../cyfxbulksrcsink.c **** 
 408:../cyfxbulksrcsink.c ****     /* Disable endpoints. */
 409:../cyfxbulksrcsink.c ****     CyU3PMemSet ((uint8_t *)&epCfg, 0, sizeof (epCfg));
 793              		.loc 1 409 0
 794 0558 14304BE2 		sub	r3, fp, #20
 795 055c 0300A0E1 		mov	r0, r3
 796 0560 0010A0E3 		mov	r1, #0
 797 0564 0C20A0E3 		mov	r2, #12
 798 0568 FEFFFFEB 		bl	CyU3PMemSet
 410:../cyfxbulksrcsink.c ****     epCfg.enable = CyFalse;
 799              		.loc 1 410 0
 800 056c 0030A0E3 		mov	r3, #0
 801 0570 14300BE5 		str	r3, [fp, #-20]
 411:../cyfxbulksrcsink.c **** 
 412:../cyfxbulksrcsink.c ****     /* Producer endpoint configuration. */
 413:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_PRODUCER, &epCfg);
 802              		.loc 1 413 0
 803 0574 14304BE2 		sub	r3, fp, #20
 804 0578 0100A0E3 		mov	r0, #1
 805 057c 0310A0E1 		mov	r1, r3
 806 0580 FEFFFFEB 		bl	CyU3PSetEpConfig
 807 0584 08000BE5 		str	r0, [fp, #-8]
 414:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 808              		.loc 1 414 0
 809 0588 08301BE5 		ldr	r3, [fp, #-8]
 810 058c 000053E3 		cmp	r3, #0
 811 0590 0500000A 		beq	.L33
 415:../cyfxbulksrcsink.c ****     {
 416:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 812              		.loc 1 416 0
 813 0594 0400A0E3 		mov	r0, #4
 814 0598 58109FE5 		ldr	r1, .L35+12
 815 059c 08201BE5 		ldr	r2, [fp, #-8]
 816 05a0 FEFFFFEB 		bl	CyU3PDebugPrint
 417:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (apiRetStatus);
 817              		.loc 1 417 0
 818 05a4 08001BE5 		ldr	r0, [fp, #-8]
 819 05a8 FEFFFFEB 		bl	CyFxAppErrorHandler
 820              	.L33:
 418:../cyfxbulksrcsink.c ****     }
 419:../cyfxbulksrcsink.c **** 
 420:../cyfxbulksrcsink.c ****     /* Consumer endpoint configuration. */
 421:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_CONSUMER, &epCfg);
 821              		.loc 1 421 0
 822 05ac 14304BE2 		sub	r3, fp, #20
 823 05b0 8100A0E3 		mov	r0, #129
 824 05b4 0310A0E1 		mov	r1, r3
 825 05b8 FEFFFFEB 		bl	CyU3PSetEpConfig
 826 05bc 08000BE5 		str	r0, [fp, #-8]
 422:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 827              		.loc 1 422 0
 828 05c0 08301BE5 		ldr	r3, [fp, #-8]
 829 05c4 000053E3 		cmp	r3, #0
 830 05c8 0500000A 		beq	.L32
 423:../cyfxbulksrcsink.c ****     {
 424:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 831              		.loc 1 424 0
 832 05cc 0400A0E3 		mov	r0, #4
 833 05d0 20109FE5 		ldr	r1, .L35+12
 834 05d4 08201BE5 		ldr	r2, [fp, #-8]
 835 05d8 FEFFFFEB 		bl	CyU3PDebugPrint
 425:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (apiRetStatus);
 836              		.loc 1 425 0
 837 05dc 08001BE5 		ldr	r0, [fp, #-8]
 838 05e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 839              	.L32:
 426:../cyfxbulksrcsink.c ****     }
 427:../cyfxbulksrcsink.c **** }
 840              		.loc 1 427 0
 841 05e4 04D04BE2 		sub	sp, fp, #4
 842 05e8 0088BDE8 		ldmfd	sp!, {fp, pc}
 843              	.L36:
 844              		.align	2
 845              	.L35:
 846 05ec 00000000 		.word	glIsApplnActive
 847 05f0 00000000 		.word	glChHandleBulkSink
 848 05f4 00000000 		.word	glChHandleBulkSrc
 849 05f8 DC000000 		.word	.LC4
 850              		.cfi_endproc
 851              	.LFE3:
 853              		.align	2
 854              		.global	CyFxBulkSrcSinkApplnUSBSetupCB
 856              	CyFxBulkSrcSinkApplnUSBSetupCB:
 857              	.LFB4:
 428:../cyfxbulksrcsink.c **** 
 429:../cyfxbulksrcsink.c **** /* Callback to handle the USB setup requests. */
 430:../cyfxbulksrcsink.c **** CyBool_t
 431:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnUSBSetupCB (
 432:../cyfxbulksrcsink.c ****         uint32_t setupdat0, /* SETUP Data 0 */
 433:../cyfxbulksrcsink.c ****         uint32_t setupdat1  /* SETUP Data 1 */
 434:../cyfxbulksrcsink.c ****     )
 435:../cyfxbulksrcsink.c **** {
 858              		.loc 1 435 0
 859              		.cfi_startproc
 860              		@ args = 0, pretend = 0, frame = 24
 861              		@ frame_needed = 1, uses_anonymous_args = 0
 862 05fc 00482DE9 		stmfd	sp!, {fp, lr}
 863              	.LCFI8:
 864              		.cfi_def_cfa_offset 8
 865 0600 04B08DE2 		add	fp, sp, #4
 866              		.cfi_offset 14, -4
 867              		.cfi_offset 11, -8
 868              	.LCFI9:
 869              		.cfi_def_cfa 11, 4
 870 0604 18D04DE2 		sub	sp, sp, #24
 871 0608 18000BE5 		str	r0, [fp, #-24]
 872 060c 1C100BE5 		str	r1, [fp, #-28]
 436:../cyfxbulksrcsink.c ****     /* Fast enumeration is used. Only requests addressed to the interface, class,
 437:../cyfxbulksrcsink.c ****      * vendor and unknown control requests are received by this function.
 438:../cyfxbulksrcsink.c ****      * This application does not support any class or vendor requests. */
 439:../cyfxbulksrcsink.c **** 
 440:../cyfxbulksrcsink.c ****     uint8_t  bRequest, bReqType;
 441:../cyfxbulksrcsink.c ****     uint8_t  bType, bTarget;
 442:../cyfxbulksrcsink.c ****     uint16_t wValue, wIndex, wLength;
 443:../cyfxbulksrcsink.c ****     CyBool_t isHandled = CyFalse;
 873              		.loc 1 443 0
 874 0610 0030A0E3 		mov	r3, #0
 875 0614 08300BE5 		str	r3, [fp, #-8]
 444:../cyfxbulksrcsink.c **** 
 445:../cyfxbulksrcsink.c ****     /* Decode the fields from the setup request. */
 446:../cyfxbulksrcsink.c ****     bReqType = (setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
 876              		.loc 1 446 0
 877 0618 18301BE5 		ldr	r3, [fp, #-24]
 878 061c 09304BE5 		strb	r3, [fp, #-9]
 447:../cyfxbulksrcsink.c ****     bType    = (bReqType & CY_U3P_USB_TYPE_MASK);
 879              		.loc 1 447 0
 880 0620 09305BE5 		ldrb	r3, [fp, #-9]
 881 0624 603003E2 		and	r3, r3, #96
 882 0628 0A304BE5 		strb	r3, [fp, #-10]
 448:../cyfxbulksrcsink.c ****     bTarget  = (bReqType & CY_U3P_USB_TARGET_MASK);
 883              		.loc 1 448 0
 884 062c 09305BE5 		ldrb	r3, [fp, #-9]
 885 0630 033003E2 		and	r3, r3, #3
 886 0634 0B304BE5 		strb	r3, [fp, #-11]
 449:../cyfxbulksrcsink.c ****     bRequest = ((setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
 887              		.loc 1 449 0
 888 0638 18301BE5 		ldr	r3, [fp, #-24]
 889 063c FF3C03E2 		and	r3, r3, #65280
 890 0640 2334A0E1 		mov	r3, r3, lsr #8
 891 0644 0C304BE5 		strb	r3, [fp, #-12]
 450:../cyfxbulksrcsink.c ****     wValue   = ((setupdat0 & CY_U3P_USB_VALUE_MASK)   >> CY_U3P_USB_VALUE_POS);
 892              		.loc 1 450 0
 893 0648 18301BE5 		ldr	r3, [fp, #-24]
 894 064c 2338A0E1 		mov	r3, r3, lsr #16
 895 0650 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 451:../cyfxbulksrcsink.c ****     wIndex   = ((setupdat1 & CY_U3P_USB_INDEX_MASK)   >> CY_U3P_USB_INDEX_POS);
 896              		.loc 1 451 0
 897 0654 1C301BE5 		ldr	r3, [fp, #-28]
 898 0658 B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 452:../cyfxbulksrcsink.c ****     wLength  = ((setupdat1 & CY_U3P_USB_LENGTH_MASK)  >> CY_U3P_USB_LENGTH_POS);
 899              		.loc 1 452 0
 900 065c 1C301BE5 		ldr	r3, [fp, #-28]
 901 0660 2338A0E1 		mov	r3, r3, lsr #16
 902 0664 B2314BE1 		strh	r3, [fp, #-18]	@ movhi
 453:../cyfxbulksrcsink.c **** 
 454:../cyfxbulksrcsink.c ****     if (bType == CY_U3P_USB_STANDARD_RQT)
 903              		.loc 1 454 0
 904 0668 0A305BE5 		ldrb	r3, [fp, #-10]	@ zero_extendqisi2
 905 066c 000053E3 		cmp	r3, #0
 906 0670 5B00001A 		bne	.L38
 455:../cyfxbulksrcsink.c ****     {
 456:../cyfxbulksrcsink.c ****         /* Handle SET_FEATURE(FUNCTION_SUSPEND) and CLEAR_FEATURE(FUNCTION_SUSPEND)
 457:../cyfxbulksrcsink.c ****          * requests here. It should be allowed to pass if the device is in configured
 458:../cyfxbulksrcsink.c ****          * state and failed otherwise. */
 459:../cyfxbulksrcsink.c ****         if ((bTarget == CY_U3P_USB_TARGET_INTF) && ((bRequest == CY_U3P_USB_SC_SET_FEATURE)
 907              		.loc 1 459 0
 908 0674 0B305BE5 		ldrb	r3, [fp, #-11]	@ zero_extendqisi2
 909 0678 010053E3 		cmp	r3, #1
 910 067c 2100001A 		bne	.L39
 911              		.loc 1 459 0 is_stmt 0 discriminator 1
 912 0680 0C305BE5 		ldrb	r3, [fp, #-12]	@ zero_extendqisi2
 913 0684 030053E3 		cmp	r3, #3
 914 0688 0200000A 		beq	.L40
 460:../cyfxbulksrcsink.c ****                     || (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)) && (wValue == 0))
 915              		.loc 1 460 0 is_stmt 1
 916 068c 0C305BE5 		ldrb	r3, [fp, #-12]	@ zero_extendqisi2
 917 0690 010053E3 		cmp	r3, #1
 918 0694 1B00001A 		bne	.L39
 919              	.L40:
 920              		.loc 1 460 0 is_stmt 0 discriminator 1
 921 0698 BE305BE1 		ldrh	r3, [fp, #-14]
 922 069c 000053E3 		cmp	r3, #0
 923 06a0 1800001A 		bne	.L39
 461:../cyfxbulksrcsink.c ****         {
 462:../cyfxbulksrcsink.c ****             if (glIsApplnActive)
 924              		.loc 1 462 0 is_stmt 1
 925 06a4 90319FE5 		ldr	r3, .L46
 926 06a8 003093E5 		ldr	r3, [r3, #0]
 927 06ac 000053E3 		cmp	r3, #0
 928 06b0 0E00000A 		beq	.L41
 463:../cyfxbulksrcsink.c ****             {
 464:../cyfxbulksrcsink.c ****                 CyU3PUsbAckSetup ();
 929              		.loc 1 464 0
 930 06b4 FEFFFFEB 		bl	CyU3PUsbAckSetup
 465:../cyfxbulksrcsink.c **** 
 466:../cyfxbulksrcsink.c ****                 /* As we have only one interface, the link can be pushed into U2 state as soon as
 467:../cyfxbulksrcsink.c ****                    this interface is suspended.
 468:../cyfxbulksrcsink.c ****                  */
 469:../cyfxbulksrcsink.c ****                 if (bRequest == CY_U3P_USB_SC_SET_FEATURE)
 931              		.loc 1 469 0
 932 06b8 0C305BE5 		ldrb	r3, [fp, #-12]	@ zero_extendqisi2
 933 06bc 030053E3 		cmp	r3, #3
 934 06c0 0600001A 		bne	.L42
 470:../cyfxbulksrcsink.c ****                 {
 471:../cyfxbulksrcsink.c ****                     glDataTransStarted = CyFalse;
 935              		.loc 1 471 0
 936 06c4 74319FE5 		ldr	r3, .L46+4
 937 06c8 0020A0E3 		mov	r2, #0
 938 06cc 002083E5 		str	r2, [r3, #0]
 472:../cyfxbulksrcsink.c ****                     glForceLinkU2      = CyTrue;
 939              		.loc 1 472 0
 940 06d0 6C319FE5 		ldr	r3, .L46+8
 941 06d4 0120A0E3 		mov	r2, #1
 942 06d8 002083E5 		str	r2, [r3, #0]
 943 06dc 070000EA 		b	.L43
 944              	.L42:
 473:../cyfxbulksrcsink.c ****                 }
 474:../cyfxbulksrcsink.c ****                 else
 475:../cyfxbulksrcsink.c ****                 {
 476:../cyfxbulksrcsink.c ****                     glForceLinkU2 = CyFalse;
 945              		.loc 1 476 0
 946 06e0 5C319FE5 		ldr	r3, .L46+8
 947 06e4 0020A0E3 		mov	r2, #0
 948 06e8 002083E5 		str	r2, [r3, #0]
 949 06ec 030000EA 		b	.L43
 950              	.L41:
 477:../cyfxbulksrcsink.c ****                 }
 478:../cyfxbulksrcsink.c ****             }
 479:../cyfxbulksrcsink.c ****             else
 480:../cyfxbulksrcsink.c ****                 CyU3PUsbStall (0, CyTrue, CyFalse);
 951              		.loc 1 480 0
 952 06f0 0000A0E3 		mov	r0, #0
 953 06f4 0110A0E3 		mov	r1, #1
 954 06f8 0020A0E3 		mov	r2, #0
 955 06fc FEFFFFEB 		bl	CyU3PUsbStall
 956              	.L43:
 481:../cyfxbulksrcsink.c **** 
 482:../cyfxbulksrcsink.c ****             isHandled = CyTrue;
 957              		.loc 1 482 0
 958 0700 0130A0E3 		mov	r3, #1
 959 0704 08300BE5 		str	r3, [fp, #-8]
 960              	.L39:
 483:../cyfxbulksrcsink.c ****         }
 484:../cyfxbulksrcsink.c **** 
 485:../cyfxbulksrcsink.c ****         /* CLEAR_FEATURE request for endpoint is always passed to the setup callback
 486:../cyfxbulksrcsink.c ****          * regardless of the enumeration model used. When a clear feature is received,
 487:../cyfxbulksrcsink.c ****          * the previous transfer has to be flushed and cleaned up. This is done at the
 488:../cyfxbulksrcsink.c ****          * protocol level. Since this is just a loopback operation, there is no higher
 489:../cyfxbulksrcsink.c ****          * level protocol. So flush the EP memory and reset the DMA channel associated
 490:../cyfxbulksrcsink.c ****          * with it. If there are more than one EP associated with the channel reset both
 491:../cyfxbulksrcsink.c ****          * the EPs. The endpoint stall and toggle / sequence number is also expected to be
 492:../cyfxbulksrcsink.c ****          * reset. Return CyFalse to make the library clear the stall and reset the endpoint
 493:../cyfxbulksrcsink.c ****          * toggle. Or invoke the CyU3PUsbStall (ep, CyFalse, CyTrue) and return CyTrue.
 494:../cyfxbulksrcsink.c ****          * Here we are clearing the stall. */
 495:../cyfxbulksrcsink.c ****         if ((bTarget == CY_U3P_USB_TARGET_ENDPT) && (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 961              		.loc 1 495 0
 962 0708 0B305BE5 		ldrb	r3, [fp, #-11]	@ zero_extendqisi2
 963 070c 020053E3 		cmp	r3, #2
 964 0710 3300001A 		bne	.L38
 965              		.loc 1 495 0 is_stmt 0 discriminator 1
 966 0714 0C305BE5 		ldrb	r3, [fp, #-12]	@ zero_extendqisi2
 967 0718 010053E3 		cmp	r3, #1
 968 071c 3000001A 		bne	.L38
 496:../cyfxbulksrcsink.c ****                 && (wValue == CY_U3P_USBX_FS_EP_HALT))
 969              		.loc 1 496 0 is_stmt 1
 970 0720 BE305BE1 		ldrh	r3, [fp, #-14]
 971 0724 000053E3 		cmp	r3, #0
 972 0728 2D00001A 		bne	.L38
 497:../cyfxbulksrcsink.c ****         {
 498:../cyfxbulksrcsink.c ****             if (glIsApplnActive)
 973              		.loc 1 498 0
 974 072c 08319FE5 		ldr	r3, .L46
 975 0730 003093E5 		ldr	r3, [r3, #0]
 976 0734 000053E3 		cmp	r3, #0
 977 0738 2900000A 		beq	.L38
 499:../cyfxbulksrcsink.c ****             {
 500:../cyfxbulksrcsink.c ****                 if (wIndex == CY_FX_EP_PRODUCER)
 978              		.loc 1 500 0
 979 073c B0315BE1 		ldrh	r3, [fp, #-16]
 980 0740 010053E3 		cmp	r3, #1
 981 0744 1100001A 		bne	.L44
 501:../cyfxbulksrcsink.c ****                 {
 502:../cyfxbulksrcsink.c ****                     CyU3PDmaChannelReset (&glChHandleBulkSink);
 982              		.loc 1 502 0
 983 0748 F8009FE5 		ldr	r0, .L46+12
 984 074c FEFFFFEB 		bl	CyU3PDmaChannelReset
 503:../cyfxbulksrcsink.c ****                     CyU3PUsbFlushEp(CY_FX_EP_PRODUCER);
 985              		.loc 1 503 0
 986 0750 0100A0E3 		mov	r0, #1
 987 0754 FEFFFFEB 		bl	CyU3PUsbFlushEp
 504:../cyfxbulksrcsink.c ****                     CyU3PUsbResetEp (CY_FX_EP_PRODUCER);
 988              		.loc 1 504 0
 989 0758 0100A0E3 		mov	r0, #1
 990 075c FEFFFFEB 		bl	CyU3PUsbResetEp
 505:../cyfxbulksrcsink.c ****                     CyU3PDmaChannelSetXfer (&glChHandleBulkSink, CY_FX_BULKSRCSINK_DMA_TX_SIZE);
 991              		.loc 1 505 0
 992 0760 E0009FE5 		ldr	r0, .L46+12
 993 0764 0010A0E3 		mov	r1, #0
 994 0768 FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 506:../cyfxbulksrcsink.c ****                     CyU3PUsbStall (wIndex, CyFalse, CyTrue);
 995              		.loc 1 506 0
 996 076c B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 997 0770 FF3003E2 		and	r3, r3, #255
 998 0774 0300A0E1 		mov	r0, r3
 999 0778 0010A0E3 		mov	r1, #0
 1000 077c 0120A0E3 		mov	r2, #1
 1001 0780 FEFFFFEB 		bl	CyU3PUsbStall
 507:../cyfxbulksrcsink.c ****                     isHandled = CyTrue;
 1002              		.loc 1 507 0
 1003 0784 0130A0E3 		mov	r3, #1
 1004 0788 08300BE5 		str	r3, [fp, #-8]
 508:../cyfxbulksrcsink.c ****                     CyU3PUsbAckSetup ();
 1005              		.loc 1 508 0
 1006 078c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1007              	.L44:
 509:../cyfxbulksrcsink.c ****                 }
 510:../cyfxbulksrcsink.c **** 
 511:../cyfxbulksrcsink.c ****                 if (wIndex == CY_FX_EP_CONSUMER)
 1008              		.loc 1 511 0
 1009 0790 B0315BE1 		ldrh	r3, [fp, #-16]
 1010 0794 810053E3 		cmp	r3, #129
 1011 0798 1100001A 		bne	.L38
 512:../cyfxbulksrcsink.c ****                 {
 513:../cyfxbulksrcsink.c ****                     CyU3PDmaChannelReset (&glChHandleBulkSrc);
 1012              		.loc 1 513 0
 1013 079c A8009FE5 		ldr	r0, .L46+16
 1014 07a0 FEFFFFEB 		bl	CyU3PDmaChannelReset
 514:../cyfxbulksrcsink.c ****                     CyU3PUsbFlushEp(CY_FX_EP_CONSUMER);
 1015              		.loc 1 514 0
 1016 07a4 8100A0E3 		mov	r0, #129
 1017 07a8 FEFFFFEB 		bl	CyU3PUsbFlushEp
 515:../cyfxbulksrcsink.c ****                     CyU3PUsbResetEp (CY_FX_EP_CONSUMER);
 1018              		.loc 1 515 0
 1019 07ac 8100A0E3 		mov	r0, #129
 1020 07b0 FEFFFFEB 		bl	CyU3PUsbResetEp
 516:../cyfxbulksrcsink.c ****                     CyU3PDmaChannelSetXfer (&glChHandleBulkSrc, CY_FX_BULKSRCSINK_DMA_TX_SIZE);
 1021              		.loc 1 516 0
 1022 07b4 90009FE5 		ldr	r0, .L46+16
 1023 07b8 0010A0E3 		mov	r1, #0
 1024 07bc FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 517:../cyfxbulksrcsink.c ****                     CyU3PUsbStall (wIndex, CyFalse, CyTrue);
 1025              		.loc 1 517 0
 1026 07c0 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 1027 07c4 FF3003E2 		and	r3, r3, #255
 1028 07c8 0300A0E1 		mov	r0, r3
 1029 07cc 0010A0E3 		mov	r1, #0
 1030 07d0 0120A0E3 		mov	r2, #1
 1031 07d4 FEFFFFEB 		bl	CyU3PUsbStall
 518:../cyfxbulksrcsink.c ****                     isHandled = CyTrue;
 1032              		.loc 1 518 0
 1033 07d8 0130A0E3 		mov	r3, #1
 1034 07dc 08300BE5 		str	r3, [fp, #-8]
 519:../cyfxbulksrcsink.c ****                     CyU3PUsbAckSetup ();
 1035              		.loc 1 519 0
 1036 07e0 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1037              	.L38:
 520:../cyfxbulksrcsink.c ****                 }
 521:../cyfxbulksrcsink.c ****             }
 522:../cyfxbulksrcsink.c ****         }
 523:../cyfxbulksrcsink.c ****     }
 524:../cyfxbulksrcsink.c **** 
 525:../cyfxbulksrcsink.c ****     if ((bType == CY_U3P_USB_VENDOR_RQT) && (bTarget == CY_U3P_USB_TARGET_DEVICE))
 1038              		.loc 1 525 0
 1039 07e4 0A305BE5 		ldrb	r3, [fp, #-10]	@ zero_extendqisi2
 1040 07e8 400053E3 		cmp	r3, #64
 1041 07ec 0E00001A 		bne	.L45
 1042              		.loc 1 525 0 is_stmt 0 discriminator 1
 1043 07f0 0B305BE5 		ldrb	r3, [fp, #-11]	@ zero_extendqisi2
 1044 07f4 000053E3 		cmp	r3, #0
 1045 07f8 0B00001A 		bne	.L45
 526:../cyfxbulksrcsink.c ****     {
 527:../cyfxbulksrcsink.c ****         /* We set an event here and let the application thread below handle these requests.
 528:../cyfxbulksrcsink.c ****          * isHandled needs to be set to True, so that the driver does not stall EP0. */
 529:../cyfxbulksrcsink.c ****         isHandled = CyTrue;
 1046              		.loc 1 529 0 is_stmt 1
 1047 07fc 0130A0E3 		mov	r3, #1
 1048 0800 08300BE5 		str	r3, [fp, #-8]
 530:../cyfxbulksrcsink.c ****         gl_setupdat0 = setupdat0;
 1049              		.loc 1 530 0
 1050 0804 44309FE5 		ldr	r3, .L46+20
 1051 0808 18201BE5 		ldr	r2, [fp, #-24]
 1052 080c 002083E5 		str	r2, [r3, #0]
 531:../cyfxbulksrcsink.c ****         gl_setupdat1 = setupdat1;
 1053              		.loc 1 531 0
 1054 0810 3C309FE5 		ldr	r3, .L46+24
 1055 0814 1C201BE5 		ldr	r2, [fp, #-28]
 1056 0818 002083E5 		str	r2, [r3, #0]
 532:../cyfxbulksrcsink.c ****         CyU3PEventSet (&glBulkLpEvent, CYFX_USB_CTRL_TASK, CYU3P_EVENT_OR);
 1057              		.loc 1 532 0
 1058 081c 34009FE5 		ldr	r0, .L46+28
 1059 0820 0110A0E3 		mov	r1, #1
 1060 0824 0020A0E3 		mov	r2, #0
 1061 0828 FEFFFFEB 		bl	_txe_event_flags_set
 1062              	.L45:
 533:../cyfxbulksrcsink.c ****     }
 534:../cyfxbulksrcsink.c **** 
 535:../cyfxbulksrcsink.c ****     return isHandled;
 1063              		.loc 1 535 0
 1064 082c 08301BE5 		ldr	r3, [fp, #-8]
 536:../cyfxbulksrcsink.c **** }
 1065              		.loc 1 536 0
 1066 0830 0300A0E1 		mov	r0, r3
 1067 0834 04D04BE2 		sub	sp, fp, #4
 1068 0838 0088BDE8 		ldmfd	sp!, {fp, pc}
 1069              	.L47:
 1070              		.align	2
 1071              	.L46:
 1072 083c 00000000 		.word	glIsApplnActive
 1073 0840 00000000 		.word	glDataTransStarted
 1074 0844 00000000 		.word	glForceLinkU2
 1075 0848 00000000 		.word	glChHandleBulkSink
 1076 084c 00000000 		.word	glChHandleBulkSrc
 1077 0850 00000000 		.word	gl_setupdat0
 1078 0854 00000000 		.word	gl_setupdat1
 1079 0858 00000000 		.word	glBulkLpEvent
 1080              		.cfi_endproc
 1081              	.LFE4:
 1083              		.section	.rodata
 1084              		.align	2
 1085              	.LC7:
 1086 0168 43595F55 		.ascii	"CY_U3P_USB_EVENT_CONNECT detected (%d)\012\000"
 1086      33505F55 
 1086      53425F45 
 1086      56454E54 
 1086      5F434F4E 
 1087              		.align	2
 1088              	.LC8:
 1089 0190 43595F55 		.ascii	"CY_U3P_USB_EVENT_DISCONNECT detected (%d)\012\000"
 1089      33505F55 
 1089      53425F45 
 1089      56454E54 
 1089      5F444953 
 1090              		.text
 1091              		.align	2
 1092              		.global	CyFxBulkSrcSinkApplnUSBEventCB
 1094              	CyFxBulkSrcSinkApplnUSBEventCB:
 1095              	.LFB5:
 537:../cyfxbulksrcsink.c **** 
 538:../cyfxbulksrcsink.c **** /* This is the callback function to handle the USB events. */
 539:../cyfxbulksrcsink.c **** void
 540:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnUSBEventCB (
 541:../cyfxbulksrcsink.c ****     CyU3PUsbEventType_t evtype, /* Event type */
 542:../cyfxbulksrcsink.c ****     uint16_t            evdata  /* Event data */
 543:../cyfxbulksrcsink.c ****     )
 544:../cyfxbulksrcsink.c **** {
 1096              		.loc 1 544 0
 1097              		.cfi_startproc
 1098              		@ args = 0, pretend = 0, frame = 8
 1099              		@ frame_needed = 1, uses_anonymous_args = 0
 1100 085c 00482DE9 		stmfd	sp!, {fp, lr}
 1101              	.LCFI10:
 1102              		.cfi_def_cfa_offset 8
 1103 0860 04B08DE2 		add	fp, sp, #4
 1104              		.cfi_offset 14, -4
 1105              		.cfi_offset 11, -8
 1106              	.LCFI11:
 1107              		.cfi_def_cfa 11, 4
 1108 0864 08D04DE2 		sub	sp, sp, #8
 1109 0868 0020A0E1 		mov	r2, r0
 1110 086c 0130A0E1 		mov	r3, r1
 1111 0870 05204BE5 		strb	r2, [fp, #-5]
 1112 0874 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 545:../cyfxbulksrcsink.c ****     static uint32_t num_connect    = 0;
 546:../cyfxbulksrcsink.c ****     static uint32_t num_disconnect = 0;
 547:../cyfxbulksrcsink.c **** 
 548:../cyfxbulksrcsink.c ****     switch (evtype)
 1113              		.loc 1 548 0
 1114 0878 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1115 087c 0C0053E3 		cmp	r3, #12
 1116 0880 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1117 0884 4A0000EA 		b	.L61
 1118              	.L55:
 1119 0888 BC080000 		.word	.L50
 1120 088c 08090000 		.word	.L51
 1121 0890 B4090000 		.word	.L61
 1122 0894 B4090000 		.word	.L61
 1123 0898 08090000 		.word	.L51
 1124 089c EC080000 		.word	.L52
 1125 08a0 B4090000 		.word	.L61
 1126 08a4 B4090000 		.word	.L61
 1127 08a8 B4090000 		.word	.L61
 1128 08ac B4090000 		.word	.L61
 1129 08b0 70090000 		.word	.L53
 1130 08b4 B4090000 		.word	.L61
 1131 08b8 88090000 		.word	.L54
 1132              	.L50:
 549:../cyfxbulksrcsink.c ****     {
 550:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_CONNECT:
 551:../cyfxbulksrcsink.c ****       ++num_connect;
 1133              		.loc 1 551 0
 1134 08bc 0C319FE5 		ldr	r3, .L64
 1135 08c0 003093E5 		ldr	r3, [r3, #0]
 1136 08c4 012083E2 		add	r2, r3, #1
 1137 08c8 00319FE5 		ldr	r3, .L64
 1138 08cc 002083E5 		str	r2, [r3, #0]
 552:../cyfxbulksrcsink.c ****       CyU3PDebugPrint (8, "CY_U3P_USB_EVENT_CONNECT detected (%d)\n",
 1139              		.loc 1 552 0
 1140 08d0 F8309FE5 		ldr	r3, .L64
 1141 08d4 003093E5 		ldr	r3, [r3, #0]
 1142 08d8 0800A0E3 		mov	r0, #8
 1143 08dc F0109FE5 		ldr	r1, .L64+4
 1144 08e0 0320A0E1 		mov	r2, r3
 1145 08e4 FEFFFFEB 		bl	CyU3PDebugPrint
 553:../cyfxbulksrcsink.c ****                        num_connect);
 554:../cyfxbulksrcsink.c ****       break;
 1146              		.loc 1 554 0
 1147 08e8 360000EA 		b	.L48
 1148              	.L52:
 555:../cyfxbulksrcsink.c **** 
 556:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_SETCONF:
 557:../cyfxbulksrcsink.c ****         /* If the application is already active
 558:../cyfxbulksrcsink.c ****          * stop it before re-enabling. */
 559:../cyfxbulksrcsink.c ****         if (glIsApplnActive)
 1149              		.loc 1 559 0
 1150 08ec E4309FE5 		ldr	r3, .L64+8
 1151 08f0 003093E5 		ldr	r3, [r3, #0]
 1152 08f4 000053E3 		cmp	r3, #0
 1153 08f8 0000000A 		beq	.L57
 560:../cyfxbulksrcsink.c ****         {
 561:../cyfxbulksrcsink.c ****             CyFxBulkSrcSinkApplnStop ();
 1154              		.loc 1 561 0
 1155 08fc FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStop
 1156              	.L57:
 562:../cyfxbulksrcsink.c ****         }
 563:../cyfxbulksrcsink.c **** 
 564:../cyfxbulksrcsink.c ****         /* Start the source sink function. */
 565:../cyfxbulksrcsink.c ****         CyFxBulkSrcSinkApplnStart ();
 1157              		.loc 1 565 0
 1158 0900 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStart
 566:../cyfxbulksrcsink.c ****         break;
 1159              		.loc 1 566 0
 1160 0904 2F0000EA 		b	.L48
 1161              	.L51:
 567:../cyfxbulksrcsink.c **** 
 568:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_RESET:
 569:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_DISCONNECT:
 570:../cyfxbulksrcsink.c ****         glForceLinkU2 = CyFalse;
 1162              		.loc 1 570 0
 1163 0908 CC309FE5 		ldr	r3, .L64+12
 1164 090c 0020A0E3 		mov	r2, #0
 1165 0910 002083E5 		str	r2, [r3, #0]
 571:../cyfxbulksrcsink.c **** 
 572:../cyfxbulksrcsink.c ****         /* Stop the source sink function. */
 573:../cyfxbulksrcsink.c ****         if (glIsApplnActive)
 1166              		.loc 1 573 0
 1167 0914 BC309FE5 		ldr	r3, .L64+8
 1168 0918 003093E5 		ldr	r3, [r3, #0]
 1169 091c 000053E3 		cmp	r3, #0
 1170 0920 0000000A 		beq	.L58
 574:../cyfxbulksrcsink.c ****         {
 575:../cyfxbulksrcsink.c ****             CyFxBulkSrcSinkApplnStop ();
 1171              		.loc 1 575 0
 1172 0924 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStop
 1173              	.L58:
 576:../cyfxbulksrcsink.c ****         }
 577:../cyfxbulksrcsink.c ****         glDataTransStarted = CyFalse;
 1174              		.loc 1 577 0
 1175 0928 B0309FE5 		ldr	r3, .L64+16
 1176 092c 0020A0E3 		mov	r2, #0
 1177 0930 002083E5 		str	r2, [r3, #0]
 578:../cyfxbulksrcsink.c **** 
 579:../cyfxbulksrcsink.c ****         if (evtype == CY_U3P_USB_EVENT_DISCONNECT) {
 1178              		.loc 1 579 0
 1179 0934 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1180 0938 010053E3 		cmp	r3, #1
 1181 093c 1E00001A 		bne	.L62
 580:../cyfxbulksrcsink.c ****             ++num_disconnect;
 1182              		.loc 1 580 0
 1183 0940 9C309FE5 		ldr	r3, .L64+20
 1184 0944 003093E5 		ldr	r3, [r3, #0]
 1185 0948 012083E2 		add	r2, r3, #1
 1186 094c 90309FE5 		ldr	r3, .L64+20
 1187 0950 002083E5 		str	r2, [r3, #0]
 581:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (8, "CY_U3P_USB_EVENT_DISCONNECT detected (%d)\n",
 1188              		.loc 1 581 0
 1189 0954 88309FE5 		ldr	r3, .L64+20
 1190 0958 003093E5 		ldr	r3, [r3, #0]
 1191 095c 0800A0E3 		mov	r0, #8
 1192 0960 80109FE5 		ldr	r1, .L64+24
 1193 0964 0320A0E1 		mov	r2, r3
 1194 0968 FEFFFFEB 		bl	CyU3PDebugPrint
 582:../cyfxbulksrcsink.c ****                              num_disconnect);
 583:../cyfxbulksrcsink.c ****         }
 584:../cyfxbulksrcsink.c ****         break;
 1195              		.loc 1 584 0
 1196 096c 150000EA 		b	.L48
 1197              	.L53:
 585:../cyfxbulksrcsink.c **** 
 586:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_EP0_STAT_CPLT:
 587:../cyfxbulksrcsink.c ****         glEp0StatCount++;
 1198              		.loc 1 587 0
 1199 0970 74309FE5 		ldr	r3, .L64+28
 1200 0974 003093E5 		ldr	r3, [r3, #0]
 1201 0978 012083E2 		add	r2, r3, #1
 1202 097c 68309FE5 		ldr	r3, .L64+28
 1203 0980 002083E5 		str	r2, [r3, #0]
 588:../cyfxbulksrcsink.c ****         break;
 1204              		.loc 1 588 0
 1205 0984 0F0000EA 		b	.L48
 1206              	.L54:
 589:../cyfxbulksrcsink.c **** 
 590:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_VBUS_REMOVED:
 591:../cyfxbulksrcsink.c ****         if (StandbyModeEnable)
 1207              		.loc 1 591 0
 1208 0988 60309FE5 		ldr	r3, .L64+32
 1209 098c 003093E5 		ldr	r3, [r3, #0]
 1210 0990 000053E3 		cmp	r3, #0
 1211 0994 0A00000A 		beq	.L63
 592:../cyfxbulksrcsink.c ****         {
 593:../cyfxbulksrcsink.c ****             TriggerStandbyMode = CyTrue;
 1212              		.loc 1 593 0
 1213 0998 54309FE5 		ldr	r3, .L64+36
 1214 099c 0120A0E3 		mov	r2, #1
 1215 09a0 002083E5 		str	r2, [r3, #0]
 594:../cyfxbulksrcsink.c ****             StandbyModeEnable  = CyFalse;
 1216              		.loc 1 594 0
 1217 09a4 44309FE5 		ldr	r3, .L64+32
 1218 09a8 0020A0E3 		mov	r2, #0
 1219 09ac 002083E5 		str	r2, [r3, #0]
 595:../cyfxbulksrcsink.c ****         }
 596:../cyfxbulksrcsink.c ****         break;
 1220              		.loc 1 596 0
 1221 09b0 040000EA 		b	.L48
 1222              	.L61:
 597:../cyfxbulksrcsink.c **** 
 598:../cyfxbulksrcsink.c ****     default:
 599:../cyfxbulksrcsink.c ****         break;
 1223              		.loc 1 599 0
 1224 09b4 0000A0E1 		mov	r0, r0	@ nop
 1225 09b8 020000EA 		b	.L48
 1226              	.L62:
 584:../cyfxbulksrcsink.c ****         break;
 1227              		.loc 1 584 0
 1228 09bc 0000A0E1 		mov	r0, r0	@ nop
 1229 09c0 000000EA 		b	.L48
 1230              	.L63:
 596:../cyfxbulksrcsink.c ****         break;
 1231              		.loc 1 596 0
 1232 09c4 0000A0E1 		mov	r0, r0	@ nop
 1233              	.L48:
 600:../cyfxbulksrcsink.c ****     }
 601:../cyfxbulksrcsink.c **** }
 1234              		.loc 1 601 0
 1235 09c8 04D04BE2 		sub	sp, fp, #4
 1236 09cc 0088BDE8 		ldmfd	sp!, {fp, pc}
 1237              	.L65:
 1238              		.align	2
 1239              	.L64:
 1240 09d0 24000000 		.word	num_connect.6990
 1241 09d4 68010000 		.word	.LC7
 1242 09d8 00000000 		.word	glIsApplnActive
 1243 09dc 00000000 		.word	glForceLinkU2
 1244 09e0 00000000 		.word	glDataTransStarted
 1245 09e4 28000000 		.word	num_disconnect.6991
 1246 09e8 90010000 		.word	.LC8
 1247 09ec 00000000 		.word	glEp0StatCount
 1248 09f0 00000000 		.word	StandbyModeEnable
 1249 09f4 00000000 		.word	TriggerStandbyMode
 1250              		.cfi_endproc
 1251              	.LFE5:
 1253              		.align	2
 1254              		.global	CyFxBulkSrcSinkApplnLPMRqtCB
 1256              	CyFxBulkSrcSinkApplnLPMRqtCB:
 1257              	.LFB6:
 602:../cyfxbulksrcsink.c **** 
 603:../cyfxbulksrcsink.c **** /* Callback function to handle LPM requests from the USB 3.0 host. This function is invoked by the 
 604:../cyfxbulksrcsink.c ****    whenever a state change from U0 -> U1 or U0 -> U2 happens. If we return CyTrue from this functio
 605:../cyfxbulksrcsink.c ****    FX3 device is retained in the low power state. If we return CyFalse, the FX3 device immediately 
 606:../cyfxbulksrcsink.c ****    to trigger an exit back to U0.
 607:../cyfxbulksrcsink.c **** 
 608:../cyfxbulksrcsink.c ****    This application does not have any state in which we should not allow U1/U2 transitions; and the
 609:../cyfxbulksrcsink.c ****    the function always return CyTrue.
 610:../cyfxbulksrcsink.c ****  */
 611:../cyfxbulksrcsink.c **** CyBool_t
 612:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnLPMRqtCB (
 613:../cyfxbulksrcsink.c ****         CyU3PUsbLinkPowerMode link_mode)
 614:../cyfxbulksrcsink.c **** {
 1258              		.loc 1 614 0
 1259              		.cfi_startproc
 1260              		@ args = 0, pretend = 0, frame = 8
 1261              		@ frame_needed = 1, uses_anonymous_args = 0
 1262              		@ link register save eliminated.
 1263 09f8 04B02DE5 		str	fp, [sp, #-4]!
 1264              	.LCFI12:
 1265              		.cfi_def_cfa_offset 4
 1266 09fc 00B08DE2 		add	fp, sp, #0
 1267              		.cfi_offset 11, -4
 1268              	.LCFI13:
 1269              		.cfi_def_cfa_register 11
 1270 0a00 0CD04DE2 		sub	sp, sp, #12
 1271 0a04 0030A0E1 		mov	r3, r0
 1272 0a08 05304BE5 		strb	r3, [fp, #-5]
 615:../cyfxbulksrcsink.c ****     return CyTrue;
 1273              		.loc 1 615 0
 1274 0a0c 0130A0E3 		mov	r3, #1
 616:../cyfxbulksrcsink.c **** }
 1275              		.loc 1 616 0
 1276 0a10 0300A0E1 		mov	r0, r3
 1277 0a14 00D08BE2 		add	sp, fp, #0
 1278 0a18 04B09DE4 		ldmfd	sp!, {fp}
 1279 0a1c 1EFF2FE1 		bx	lr
 1280              		.cfi_endproc
 1281              	.LFE6:
 1283              		.section	.rodata
 1284 01bb 00       		.align	2
 1285              	.LC9:
 1286 01bc 43795533 		.ascii	"CyU3PUsbStart failed to Start, Error code = %d\012\000"
 1286      50557362 
 1286      53746172 
 1286      74206661 
 1286      696C6564 
 1287              		.align	2
 1288              	.LC10:
 1289 01ec 43795533 		.ascii	"CyU3PGpifLoad failed, Error Code = %d\012\000"
 1289      50477069 
 1289      664C6F61 
 1289      64206661 
 1289      696C6564 
 1290 0213 00       		.align	2
 1291              	.LC11:
 1292 0214 43795533 		.ascii	"CyU3PGpifSMStart failed, Error Code = %d\012\000"
 1292      50477069 
 1292      66534D53 
 1292      74617274 
 1292      20666169 
 1293 023e 0000     		.align	2
 1294              	.LC12:
 1295 0240 55534220 		.ascii	"USB set device descriptor failed, Error code = %d\012"
 1295      73657420 
 1295      64657669 
 1295      63652064 
 1295      65736372 
 1296 0272 00       		.ascii	"\000"
 1297 0273 00       		.align	2
 1298              	.LC13:
 1299 0274 55534220 		.ascii	"USB set configuration descriptor failed, Error code"
 1299      73657420 
 1299      636F6E66 
 1299      69677572 
 1299      6174696F 
 1300 02a7 203D2025 		.ascii	" = %d\012\000"
 1300      640A00
 1301 02ae 0000     		.align	2
 1302              	.LC14:
 1303 02b0 55534220 		.ascii	"USB set device qualifier descriptor failed, Error c"
 1303      73657420 
 1303      64657669 
 1303      63652071 
 1303      75616C69 
 1304 02e3 6F646520 		.ascii	"ode = %d\012\000"
 1304      3D202564 
 1304      0A00
 1305 02ed 000000   		.align	2
 1306              	.LC15:
 1307 02f0 55534220 		.ascii	"USB Set Other Speed Descriptor failed, Error Code ="
 1307      53657420 
 1307      4F746865 
 1307      72205370 
 1307      65656420 
 1308 0323 2025640A 		.ascii	" %d\012\000"
 1308      00
 1309              		.align	2
 1310              	.LC16:
 1311 0328 55534220 		.ascii	"USB Set Configuration Descriptor failed, Error Code"
 1311      53657420 
 1311      436F6E66 
 1311      69677572 
 1311      6174696F 
 1312 035b 203D2025 		.ascii	" = %d\012\000"
 1312      640A00
 1313 0362 0000     		.align	2
 1314              	.LC17:
 1315 0364 55534220 		.ascii	"USB set string descriptor failed, Error code = %d\012"
 1315      73657420 
 1315      73747269 
 1315      6E672064 
 1315      65736372 
 1316 0396 00       		.ascii	"\000"
 1317 0397 00       		.align	2
 1318              	.LC18:
 1319 0398 41626F75 		.ascii	"About to connect to USB host\015\012\000"
 1319      7420746F 
 1319      20636F6E 
 1319      6E656374 
 1319      20746F20 
 1320 03b7 00       		.align	2
 1321              	.LC19:
 1322 03b8 55534220 		.ascii	"USB Connect failed, Error code = %d\012\000"
 1322      436F6E6E 
 1322      65637420 
 1322      6661696C 
 1322      65642C20 
 1323 03dd 000000   		.align	2
 1324              	.LC20:
 1325 03e0 43794678 		.ascii	"CyFxBulkSrcSinkApplnInit complete\015\012\000"
 1325      42756C6B 
 1325      53726353 
 1325      696E6B41 
 1325      70706C6E 
 1326              		.text
 1327              		.align	2
 1328              		.global	CyFxBulkSrcSinkApplnInit
 1330              	CyFxBulkSrcSinkApplnInit:
 1331              	.LFB7:
 617:../cyfxbulksrcsink.c **** 
 618:../cyfxbulksrcsink.c **** /* This function initializes the USB Module, sets the enumeration descriptors.
 619:../cyfxbulksrcsink.c ****  * This function does not start the bulk streaming and this is done only when
 620:../cyfxbulksrcsink.c ****  * SET_CONF event is received. */
 621:../cyfxbulksrcsink.c **** void
 622:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnInit (void)
 623:../cyfxbulksrcsink.c **** {
 1332              		.loc 1 623 0
 1333              		.cfi_startproc
 1334              		@ args = 0, pretend = 0, frame = 8
 1335              		@ frame_needed = 1, uses_anonymous_args = 0
 1336 0a20 00482DE9 		stmfd	sp!, {fp, lr}
 1337              	.LCFI14:
 1338              		.cfi_def_cfa_offset 8
 1339 0a24 04B08DE2 		add	fp, sp, #4
 1340              		.cfi_offset 14, -4
 1341              		.cfi_offset 11, -8
 1342              	.LCFI15:
 1343              		.cfi_def_cfa 11, 4
 1344 0a28 08D04DE2 		sub	sp, sp, #8
 624:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 1345              		.loc 1 624 0
 1346 0a2c 0030A0E3 		mov	r3, #0
 1347 0a30 0C300BE5 		str	r3, [fp, #-12]
 625:../cyfxbulksrcsink.c ****     CyBool_t no_renum = CyFalse;
 1348              		.loc 1 625 0
 1349 0a34 0030A0E3 		mov	r3, #0
 1350 0a38 08300BE5 		str	r3, [fp, #-8]
 626:../cyfxbulksrcsink.c **** 
 627:../cyfxbulksrcsink.c ****     /* Start the USB functionality. */
 628:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbStart();
 1351              		.loc 1 628 0
 1352 0a3c FEFFFFEB 		bl	CyU3PUsbStart
 1353 0a40 0C000BE5 		str	r0, [fp, #-12]
 629:../cyfxbulksrcsink.c ****     if (apiRetStatus == CY_U3P_ERROR_NO_REENUM_REQUIRED)
 1354              		.loc 1 629 0
 1355 0a44 0C301BE5 		ldr	r3, [fp, #-12]
 1356 0a48 FE0053E3 		cmp	r3, #254
 1357 0a4c 0200001A 		bne	.L68
 630:../cyfxbulksrcsink.c ****         no_renum = CyTrue;
 1358              		.loc 1 630 0
 1359 0a50 0130A0E3 		mov	r3, #1
 1360 0a54 08300BE5 		str	r3, [fp, #-8]
 1361 0a58 080000EA 		b	.L69
 1362              	.L68:
 631:../cyfxbulksrcsink.c ****     else if (apiRetStatus != CY_U3P_SUCCESS)
 1363              		.loc 1 631 0
 1364 0a5c 0C301BE5 		ldr	r3, [fp, #-12]
 1365 0a60 000053E3 		cmp	r3, #0
 1366 0a64 0500000A 		beq	.L69
 632:../cyfxbulksrcsink.c ****     {
 633:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PUsbStart failed to Start, Error code = %d\n", apiRetStatus);
 1367              		.loc 1 633 0
 1368 0a68 0400A0E3 		mov	r0, #4
 1369 0a6c 74139FE5 		ldr	r1, .L86
 1370 0a70 0C201BE5 		ldr	r2, [fp, #-12]
 1371 0a74 FEFFFFEB 		bl	CyU3PDebugPrint
 634:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1372              		.loc 1 634 0
 1373 0a78 0C001BE5 		ldr	r0, [fp, #-12]
 1374 0a7c FEFFFFEB 		bl	CyFxAppErrorHandler
 1375              	.L69:
 635:../cyfxbulksrcsink.c ****     }
 636:../cyfxbulksrcsink.c **** 
 637:../cyfxbulksrcsink.c ****     /* Load the GPIF configuration*/
 638:../cyfxbulksrcsink.c **** 	apiRetStatus = CyU3PGpifLoad (&CyFxGpifConfig);
 1376              		.loc 1 638 0
 1377 0a80 64039FE5 		ldr	r0, .L86+4
 1378 0a84 FEFFFFEB 		bl	CyU3PGpifLoad
 1379 0a88 0C000BE5 		str	r0, [fp, #-12]
 639:../cyfxbulksrcsink.c **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1380              		.loc 1 639 0
 1381 0a8c 0C301BE5 		ldr	r3, [fp, #-12]
 1382 0a90 000053E3 		cmp	r3, #0
 1383 0a94 0500000A 		beq	.L70
 640:../cyfxbulksrcsink.c **** 	{
 641:../cyfxbulksrcsink.c **** 		CyU3PDebugPrint (4, "CyU3PGpifLoad failed, Error Code = %d\n",apiRetStatus);
 1384              		.loc 1 641 0
 1385 0a98 0400A0E3 		mov	r0, #4
 1386 0a9c 4C139FE5 		ldr	r1, .L86+8
 1387 0aa0 0C201BE5 		ldr	r2, [fp, #-12]
 1388 0aa4 FEFFFFEB 		bl	CyU3PDebugPrint
 642:../cyfxbulksrcsink.c **** 		CyFxAppErrorHandler(apiRetStatus);
 1389              		.loc 1 642 0
 1390 0aa8 0C001BE5 		ldr	r0, [fp, #-12]
 1391 0aac FEFFFFEB 		bl	CyFxAppErrorHandler
 1392              	.L70:
 643:../cyfxbulksrcsink.c **** 	}
 644:../cyfxbulksrcsink.c **** 
 645:../cyfxbulksrcsink.c **** 	/* Start the state machine. */
 646:../cyfxbulksrcsink.c **** 	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
 1393              		.loc 1 646 0
 1394 0ab0 0000A0E3 		mov	r0, #0
 1395 0ab4 0010A0E3 		mov	r1, #0
 1396 0ab8 FEFFFFEB 		bl	CyU3PGpifSMStart
 1397 0abc 0C000BE5 		str	r0, [fp, #-12]
 647:../cyfxbulksrcsink.c **** 	if (apiRetStatus != CY_U3P_SUCCESS)
 1398              		.loc 1 647 0
 1399 0ac0 0C301BE5 		ldr	r3, [fp, #-12]
 1400 0ac4 000053E3 		cmp	r3, #0
 1401 0ac8 0500000A 		beq	.L71
 648:../cyfxbulksrcsink.c **** 	{
 649:../cyfxbulksrcsink.c **** 		CyU3PDebugPrint (4, "CyU3PGpifSMStart failed, Error Code = %d\n",apiRetStatus);
 1402              		.loc 1 649 0
 1403 0acc 0400A0E3 		mov	r0, #4
 1404 0ad0 1C139FE5 		ldr	r1, .L86+12
 1405 0ad4 0C201BE5 		ldr	r2, [fp, #-12]
 1406 0ad8 FEFFFFEB 		bl	CyU3PDebugPrint
 650:../cyfxbulksrcsink.c **** 		CyFxAppErrorHandler(apiRetStatus);
 1407              		.loc 1 650 0
 1408 0adc 0C001BE5 		ldr	r0, [fp, #-12]
 1409 0ae0 FEFFFFEB 		bl	CyFxAppErrorHandler
 1410              	.L71:
 651:../cyfxbulksrcsink.c **** 	}
 652:../cyfxbulksrcsink.c **** 
 653:../cyfxbulksrcsink.c ****     /* The fast enumeration is the easiest way to setup a USB connection,
 654:../cyfxbulksrcsink.c ****      * where all enumeration phase is handled by the library. Only the
 655:../cyfxbulksrcsink.c ****      * class / vendor requests need to be handled by the application. */
 656:../cyfxbulksrcsink.c ****     CyU3PUsbRegisterSetupCallback(CyFxBulkSrcSinkApplnUSBSetupCB, CyTrue);
 1411              		.loc 1 656 0
 1412 0ae4 0C039FE5 		ldr	r0, .L86+16
 1413 0ae8 0110A0E3 		mov	r1, #1
 1414 0aec FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 657:../cyfxbulksrcsink.c **** 
 658:../cyfxbulksrcsink.c ****     /* Setup the callback to handle the USB events. */
 659:../cyfxbulksrcsink.c ****     CyU3PUsbRegisterEventCallback(CyFxBulkSrcSinkApplnUSBEventCB);
 1415              		.loc 1 659 0
 1416 0af0 04039FE5 		ldr	r0, .L86+20
 1417 0af4 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 660:../cyfxbulksrcsink.c **** 
 661:../cyfxbulksrcsink.c ****     /* Register a callback to handle LPM requests from the USB 3.0 host. */
 662:../cyfxbulksrcsink.c ****     CyU3PUsbRegisterLPMRequestCallback(CyFxBulkSrcSinkApplnLPMRqtCB);
 1418              		.loc 1 662 0
 1419 0af8 00039FE5 		ldr	r0, .L86+24
 1420 0afc FEFFFFEB 		bl	CyU3PUsbRegisterLPMRequestCallback
 663:../cyfxbulksrcsink.c **** 
 664:../cyfxbulksrcsink.c ****     /* Set the USB Enumeration descriptors */
 665:../cyfxbulksrcsink.c **** 
 666:../cyfxbulksrcsink.c ****     /* Super speed device descriptor. */
 667:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSB30Device
 1421              		.loc 1 667 0
 1422 0b00 0000A0E3 		mov	r0, #0
 1423 0b04 0010A0E3 		mov	r1, #0
 1424 0b08 F4229FE5 		ldr	r2, .L86+28
 1425 0b0c FEFFFFEB 		bl	CyU3PUsbSetDesc
 1426 0b10 0C000BE5 		str	r0, [fp, #-12]
 668:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1427              		.loc 1 668 0
 1428 0b14 0C301BE5 		ldr	r3, [fp, #-12]
 1429 0b18 000053E3 		cmp	r3, #0
 1430 0b1c 0500000A 		beq	.L72
 669:../cyfxbulksrcsink.c ****     {
 670:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\n", apiRetStatus);
 1431              		.loc 1 670 0
 1432 0b20 0400A0E3 		mov	r0, #4
 1433 0b24 DC129FE5 		ldr	r1, .L86+32
 1434 0b28 0C201BE5 		ldr	r2, [fp, #-12]
 1435 0b2c FEFFFFEB 		bl	CyU3PDebugPrint
 671:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1436              		.loc 1 671 0
 1437 0b30 0C001BE5 		ldr	r0, [fp, #-12]
 1438 0b34 FEFFFFEB 		bl	CyFxAppErrorHandler
 1439              	.L72:
 672:../cyfxbulksrcsink.c ****     }
 673:../cyfxbulksrcsink.c **** 
 674:../cyfxbulksrcsink.c ****     /* High speed device descriptor. */
 675:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSB20Device
 1440              		.loc 1 675 0
 1441 0b38 0100A0E3 		mov	r0, #1
 1442 0b3c 0010A0E3 		mov	r1, #0
 1443 0b40 C4229FE5 		ldr	r2, .L86+36
 1444 0b44 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1445 0b48 0C000BE5 		str	r0, [fp, #-12]
 676:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1446              		.loc 1 676 0
 1447 0b4c 0C301BE5 		ldr	r3, [fp, #-12]
 1448 0b50 000053E3 		cmp	r3, #0
 1449 0b54 0500000A 		beq	.L73
 677:../cyfxbulksrcsink.c ****     {
 678:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\n", apiRetStatus);
 1450              		.loc 1 678 0
 1451 0b58 0400A0E3 		mov	r0, #4
 1452 0b5c A4129FE5 		ldr	r1, .L86+32
 1453 0b60 0C201BE5 		ldr	r2, [fp, #-12]
 1454 0b64 FEFFFFEB 		bl	CyU3PDebugPrint
 679:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1455              		.loc 1 679 0
 1456 0b68 0C001BE5 		ldr	r0, [fp, #-12]
 1457 0b6c FEFFFFEB 		bl	CyFxAppErrorHandler
 1458              	.L73:
 680:../cyfxbulksrcsink.c ****     }
 681:../cyfxbulksrcsink.c **** 
 682:../cyfxbulksrcsink.c ****     /* BOS descriptor */
 683:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 1459              		.loc 1 683 0
 1460 0b70 0700A0E3 		mov	r0, #7
 1461 0b74 0010A0E3 		mov	r1, #0
 1462 0b78 90229FE5 		ldr	r2, .L86+40
 1463 0b7c FEFFFFEB 		bl	CyU3PUsbSetDesc
 1464 0b80 0C000BE5 		str	r0, [fp, #-12]
 684:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1465              		.loc 1 684 0
 1466 0b84 0C301BE5 		ldr	r3, [fp, #-12]
 1467 0b88 000053E3 		cmp	r3, #0
 1468 0b8c 0500000A 		beq	.L74
 685:../cyfxbulksrcsink.c ****     {
 686:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\n", apiRetSta
 1469              		.loc 1 686 0
 1470 0b90 0400A0E3 		mov	r0, #4
 1471 0b94 78129FE5 		ldr	r1, .L86+44
 1472 0b98 0C201BE5 		ldr	r2, [fp, #-12]
 1473 0b9c FEFFFFEB 		bl	CyU3PDebugPrint
 687:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1474              		.loc 1 687 0
 1475 0ba0 0C001BE5 		ldr	r0, [fp, #-12]
 1476 0ba4 FEFFFFEB 		bl	CyFxAppErrorHandler
 1477              	.L74:
 688:../cyfxbulksrcsink.c ****     }
 689:../cyfxbulksrcsink.c **** 
 690:../cyfxbulksrcsink.c ****     /* Device qualifier descriptor */
 691:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQual
 1478              		.loc 1 691 0
 1479 0ba8 0200A0E3 		mov	r0, #2
 1480 0bac 0010A0E3 		mov	r1, #0
 1481 0bb0 60229FE5 		ldr	r2, .L86+48
 1482 0bb4 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1483 0bb8 0C000BE5 		str	r0, [fp, #-12]
 692:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1484              		.loc 1 692 0
 1485 0bbc 0C301BE5 		ldr	r3, [fp, #-12]
 1486 0bc0 000053E3 		cmp	r3, #0
 1487 0bc4 0500000A 		beq	.L75
 693:../cyfxbulksrcsink.c ****     {
 694:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set device qualifier descriptor failed, Error code = %d\n", apiRet
 1488              		.loc 1 694 0
 1489 0bc8 0400A0E3 		mov	r0, #4
 1490 0bcc 48129FE5 		ldr	r1, .L86+52
 1491 0bd0 0C201BE5 		ldr	r2, [fp, #-12]
 1492 0bd4 FEFFFFEB 		bl	CyU3PDebugPrint
 695:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1493              		.loc 1 695 0
 1494 0bd8 0C001BE5 		ldr	r0, [fp, #-12]
 1495 0bdc FEFFFFEB 		bl	CyFxAppErrorHandler
 1496              	.L75:
 696:../cyfxbulksrcsink.c ****     }
 697:../cyfxbulksrcsink.c **** 
 698:../cyfxbulksrcsink.c ****     /* Super speed configuration descriptor */
 699:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfig
 1497              		.loc 1 699 0
 1498 0be0 0600A0E3 		mov	r0, #6
 1499 0be4 0010A0E3 		mov	r1, #0
 1500 0be8 30229FE5 		ldr	r2, .L86+56
 1501 0bec FEFFFFEB 		bl	CyU3PUsbSetDesc
 1502 0bf0 0C000BE5 		str	r0, [fp, #-12]
 700:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1503              		.loc 1 700 0
 1504 0bf4 0C301BE5 		ldr	r3, [fp, #-12]
 1505 0bf8 000053E3 		cmp	r3, #0
 1506 0bfc 0500000A 		beq	.L76
 701:../cyfxbulksrcsink.c ****     {
 702:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\n", apiRetSta
 1507              		.loc 1 702 0
 1508 0c00 0400A0E3 		mov	r0, #4
 1509 0c04 08129FE5 		ldr	r1, .L86+44
 1510 0c08 0C201BE5 		ldr	r2, [fp, #-12]
 1511 0c0c FEFFFFEB 		bl	CyU3PDebugPrint
 703:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1512              		.loc 1 703 0
 1513 0c10 0C001BE5 		ldr	r0, [fp, #-12]
 1514 0c14 FEFFFFEB 		bl	CyFxAppErrorHandler
 1515              	.L76:
 704:../cyfxbulksrcsink.c ****     }
 705:../cyfxbulksrcsink.c **** 
 706:../cyfxbulksrcsink.c ****     /* High speed configuration descriptor */
 707:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfig
 1516              		.loc 1 707 0
 1517 0c18 0400A0E3 		mov	r0, #4
 1518 0c1c 0010A0E3 		mov	r1, #0
 1519 0c20 FC219FE5 		ldr	r2, .L86+60
 1520 0c24 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1521 0c28 0C000BE5 		str	r0, [fp, #-12]
 708:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1522              		.loc 1 708 0
 1523 0c2c 0C301BE5 		ldr	r3, [fp, #-12]
 1524 0c30 000053E3 		cmp	r3, #0
 1525 0c34 0500000A 		beq	.L77
 709:../cyfxbulksrcsink.c ****     {
 710:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB Set Other Speed Descriptor failed, Error Code = %d\n", apiRetStatu
 1526              		.loc 1 710 0
 1527 0c38 0400A0E3 		mov	r0, #4
 1528 0c3c E4119FE5 		ldr	r1, .L86+64
 1529 0c40 0C201BE5 		ldr	r2, [fp, #-12]
 1530 0c44 FEFFFFEB 		bl	CyU3PDebugPrint
 711:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1531              		.loc 1 711 0
 1532 0c48 0C001BE5 		ldr	r0, [fp, #-12]
 1533 0c4c FEFFFFEB 		bl	CyFxAppErrorHandler
 1534              	.L77:
 712:../cyfxbulksrcsink.c ****     }
 713:../cyfxbulksrcsink.c **** 
 714:../cyfxbulksrcsink.c ****     /* Full speed configuration descriptor */
 715:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfig
 1535              		.loc 1 715 0
 1536 0c50 0300A0E3 		mov	r0, #3
 1537 0c54 0010A0E3 		mov	r1, #0
 1538 0c58 CC219FE5 		ldr	r2, .L86+68
 1539 0c5c FEFFFFEB 		bl	CyU3PUsbSetDesc
 1540 0c60 0C000BE5 		str	r0, [fp, #-12]
 716:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1541              		.loc 1 716 0
 1542 0c64 0C301BE5 		ldr	r3, [fp, #-12]
 1543 0c68 000053E3 		cmp	r3, #0
 1544 0c6c 0500000A 		beq	.L78
 717:../cyfxbulksrcsink.c ****     {
 718:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB Set Configuration Descriptor failed, Error Code = %d\n", apiRetSta
 1545              		.loc 1 718 0
 1546 0c70 0400A0E3 		mov	r0, #4
 1547 0c74 B4119FE5 		ldr	r1, .L86+72
 1548 0c78 0C201BE5 		ldr	r2, [fp, #-12]
 1549 0c7c FEFFFFEB 		bl	CyU3PDebugPrint
 719:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1550              		.loc 1 719 0
 1551 0c80 0C001BE5 		ldr	r0, [fp, #-12]
 1552 0c84 FEFFFFEB 		bl	CyFxAppErrorHandler
 1553              	.L78:
 720:../cyfxbulksrcsink.c ****     }
 721:../cyfxbulksrcsink.c **** 
 722:../cyfxbulksrcsink.c ****     /* String descriptor 0 */
 723:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDs
 1554              		.loc 1 723 0
 1555 0c88 0500A0E3 		mov	r0, #5
 1556 0c8c 0010A0E3 		mov	r1, #0
 1557 0c90 9C219FE5 		ldr	r2, .L86+76
 1558 0c94 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1559 0c98 0C000BE5 		str	r0, [fp, #-12]
 724:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1560              		.loc 1 724 0
 1561 0c9c 0C301BE5 		ldr	r3, [fp, #-12]
 1562 0ca0 000053E3 		cmp	r3, #0
 1563 0ca4 0500000A 		beq	.L79
 725:../cyfxbulksrcsink.c ****     {
 726:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", apiRetStatus);
 1564              		.loc 1 726 0
 1565 0ca8 0400A0E3 		mov	r0, #4
 1566 0cac 84119FE5 		ldr	r1, .L86+80
 1567 0cb0 0C201BE5 		ldr	r2, [fp, #-12]
 1568 0cb4 FEFFFFEB 		bl	CyU3PDebugPrint
 727:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1569              		.loc 1 727 0
 1570 0cb8 0C001BE5 		ldr	r0, [fp, #-12]
 1571 0cbc FEFFFFEB 		bl	CyFxAppErrorHandler
 1572              	.L79:
 728:../cyfxbulksrcsink.c ****     }
 729:../cyfxbulksrcsink.c **** 
 730:../cyfxbulksrcsink.c ****     /* String descriptor 1 */
 731:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDsc
 1573              		.loc 1 731 0
 1574 0cc0 0500A0E3 		mov	r0, #5
 1575 0cc4 0110A0E3 		mov	r1, #1
 1576 0cc8 6C219FE5 		ldr	r2, .L86+84
 1577 0ccc FEFFFFEB 		bl	CyU3PUsbSetDesc
 1578 0cd0 0C000BE5 		str	r0, [fp, #-12]
 732:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1579              		.loc 1 732 0
 1580 0cd4 0C301BE5 		ldr	r3, [fp, #-12]
 1581 0cd8 000053E3 		cmp	r3, #0
 1582 0cdc 0500000A 		beq	.L80
 733:../cyfxbulksrcsink.c ****     {
 734:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", apiRetStatus);
 1583              		.loc 1 734 0
 1584 0ce0 0400A0E3 		mov	r0, #4
 1585 0ce4 4C119FE5 		ldr	r1, .L86+80
 1586 0ce8 0C201BE5 		ldr	r2, [fp, #-12]
 1587 0cec FEFFFFEB 		bl	CyU3PDebugPrint
 735:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1588              		.loc 1 735 0
 1589 0cf0 0C001BE5 		ldr	r0, [fp, #-12]
 1590 0cf4 FEFFFFEB 		bl	CyFxAppErrorHandler
 1591              	.L80:
 736:../cyfxbulksrcsink.c ****     }
 737:../cyfxbulksrcsink.c **** 
 738:../cyfxbulksrcsink.c ****     /* String descriptor 2 */
 739:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 1592              		.loc 1 739 0
 1593 0cf8 0500A0E3 		mov	r0, #5
 1594 0cfc 0210A0E3 		mov	r1, #2
 1595 0d00 38219FE5 		ldr	r2, .L86+88
 1596 0d04 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1597 0d08 0C000BE5 		str	r0, [fp, #-12]
 740:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1598              		.loc 1 740 0
 1599 0d0c 0C301BE5 		ldr	r3, [fp, #-12]
 1600 0d10 000053E3 		cmp	r3, #0
 1601 0d14 0500000A 		beq	.L81
 741:../cyfxbulksrcsink.c ****     {
 742:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", apiRetStatus);
 1602              		.loc 1 742 0
 1603 0d18 0400A0E3 		mov	r0, #4
 1604 0d1c 14119FE5 		ldr	r1, .L86+80
 1605 0d20 0C201BE5 		ldr	r2, [fp, #-12]
 1606 0d24 FEFFFFEB 		bl	CyU3PDebugPrint
 743:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1607              		.loc 1 743 0
 1608 0d28 0C001BE5 		ldr	r0, [fp, #-12]
 1609 0d2c FEFFFFEB 		bl	CyFxAppErrorHandler
 1610              	.L81:
 744:../cyfxbulksrcsink.c ****     }
 745:../cyfxbulksrcsink.c **** 
 746:../cyfxbulksrcsink.c ****     /* Register a buffer into which the USB driver can log relevant events. */
 747:../cyfxbulksrcsink.c ****     gl_UsbLogBuffer = (uint8_t *)CyU3PDmaBufferAlloc (CYFX_USBLOG_SIZE);
 1611              		.loc 1 747 0
 1612 0d30 010AA0E3 		mov	r0, #4096
 1613 0d34 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 1614 0d38 0030A0E1 		mov	r3, r0
 1615 0d3c 0320A0E1 		mov	r2, r3
 1616 0d40 FC309FE5 		ldr	r3, .L86+92
 1617 0d44 002083E5 		str	r2, [r3, #0]
 748:../cyfxbulksrcsink.c ****     if (gl_UsbLogBuffer)
 1618              		.loc 1 748 0
 1619 0d48 F4309FE5 		ldr	r3, .L86+92
 1620 0d4c 003093E5 		ldr	r3, [r3, #0]
 1621 0d50 000053E3 		cmp	r3, #0
 1622 0d54 0400000A 		beq	.L82
 749:../cyfxbulksrcsink.c ****         CyU3PUsbInitEventLog (gl_UsbLogBuffer, CYFX_USBLOG_SIZE);
 1623              		.loc 1 749 0
 1624 0d58 E4309FE5 		ldr	r3, .L86+92
 1625 0d5c 003093E5 		ldr	r3, [r3, #0]
 1626 0d60 0300A0E1 		mov	r0, r3
 1627 0d64 011AA0E3 		mov	r1, #4096
 1628 0d68 FEFFFFEB 		bl	CyU3PUsbInitEventLog
 1629              	.L82:
 750:../cyfxbulksrcsink.c **** 
 751:../cyfxbulksrcsink.c ****     CyU3PDebugPrint (4, "About to connect to USB host\r\n");
 1630              		.loc 1 751 0
 1631 0d6c 0400A0E3 		mov	r0, #4
 1632 0d70 D0109FE5 		ldr	r1, .L86+96
 1633 0d74 FEFFFFEB 		bl	CyU3PDebugPrint
 752:../cyfxbulksrcsink.c **** 
 753:../cyfxbulksrcsink.c ****     /* Connect the USB Pins with super speed operation enabled. */
 754:../cyfxbulksrcsink.c ****     if (!no_renum) {
 1634              		.loc 1 754 0
 1635 0d78 08301BE5 		ldr	r3, [fp, #-8]
 1636 0d7c 000053E3 		cmp	r3, #0
 1637 0d80 0D00001A 		bne	.L83
 755:../cyfxbulksrcsink.c ****         apiRetStatus = CyU3PConnectState(CyTrue, CyTrue);
 1638              		.loc 1 755 0
 1639 0d84 0100A0E3 		mov	r0, #1
 1640 0d88 0110A0E3 		mov	r1, #1
 1641 0d8c FEFFFFEB 		bl	CyU3PConnectState
 1642 0d90 0C000BE5 		str	r0, [fp, #-12]
 756:../cyfxbulksrcsink.c ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1643              		.loc 1 756 0
 1644 0d94 0C301BE5 		ldr	r3, [fp, #-12]
 1645 0d98 000053E3 		cmp	r3, #0
 1646 0d9c 0C00000A 		beq	.L84
 757:../cyfxbulksrcsink.c ****         {
 758:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "USB Connect failed, Error code = %d\n", apiRetStatus);
 1647              		.loc 1 758 0
 1648 0da0 0400A0E3 		mov	r0, #4
 1649 0da4 A0109FE5 		ldr	r1, .L86+100
 1650 0da8 0C201BE5 		ldr	r2, [fp, #-12]
 1651 0dac FEFFFFEB 		bl	CyU3PDebugPrint
 759:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler(apiRetStatus);
 1652              		.loc 1 759 0
 1653 0db0 0C001BE5 		ldr	r0, [fp, #-12]
 1654 0db4 FEFFFFEB 		bl	CyFxAppErrorHandler
 1655 0db8 050000EA 		b	.L84
 1656              	.L83:
 760:../cyfxbulksrcsink.c ****         }
 761:../cyfxbulksrcsink.c ****     }
 762:../cyfxbulksrcsink.c ****     else
 763:../cyfxbulksrcsink.c ****     {
 764:../cyfxbulksrcsink.c ****         /* USB connection is already active. Configure the endpoints and DMA channels. */
 765:../cyfxbulksrcsink.c ****         if (glIsApplnActive)
 1657              		.loc 1 765 0
 1658 0dbc 8C309FE5 		ldr	r3, .L86+104
 1659 0dc0 003093E5 		ldr	r3, [r3, #0]
 1660 0dc4 000053E3 		cmp	r3, #0
 1661 0dc8 0000000A 		beq	.L85
 766:../cyfxbulksrcsink.c ****             CyFxBulkSrcSinkApplnStop ();
 1662              		.loc 1 766 0
 1663 0dcc FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStop
 1664              	.L85:
 767:../cyfxbulksrcsink.c ****         CyFxBulkSrcSinkApplnStart ();
 1665              		.loc 1 767 0
 1666 0dd0 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStart
 1667              	.L84:
 768:../cyfxbulksrcsink.c ****     }
 769:../cyfxbulksrcsink.c ****     CyU3PDebugPrint (8, "CyFxBulkSrcSinkApplnInit complete\r\n");
 1668              		.loc 1 769 0
 1669 0dd4 0800A0E3 		mov	r0, #8
 1670 0dd8 74109FE5 		ldr	r1, .L86+108
 1671 0ddc FEFFFFEB 		bl	CyU3PDebugPrint
 770:../cyfxbulksrcsink.c **** }
 1672              		.loc 1 770 0
 1673 0de0 04D04BE2 		sub	sp, fp, #4
 1674 0de4 0088BDE8 		ldmfd	sp!, {fp, pc}
 1675              	.L87:
 1676              		.align	2
 1677              	.L86:
 1678 0de8 BC010000 		.word	.LC9
 1679 0dec 00000000 		.word	CyFxGpifConfig
 1680 0df0 EC010000 		.word	.LC10
 1681 0df4 14020000 		.word	.LC11
 1682 0df8 00000000 		.word	CyFxBulkSrcSinkApplnUSBSetupCB
 1683 0dfc 00000000 		.word	CyFxBulkSrcSinkApplnUSBEventCB
 1684 0e00 00000000 		.word	CyFxBulkSrcSinkApplnLPMRqtCB
 1685 0e04 00000000 		.word	CyFxUSB30DeviceDscr
 1686 0e08 40020000 		.word	.LC12
 1687 0e0c 00000000 		.word	CyFxUSB20DeviceDscr
 1688 0e10 00000000 		.word	CyFxUSBBOSDscr
 1689 0e14 74020000 		.word	.LC13
 1690 0e18 00000000 		.word	CyFxUSBDeviceQualDscr
 1691 0e1c B0020000 		.word	.LC14
 1692 0e20 00000000 		.word	CyFxUSBSSConfigDscr
 1693 0e24 00000000 		.word	CyFxUSBHSConfigDscr
 1694 0e28 F0020000 		.word	.LC15
 1695 0e2c 00000000 		.word	CyFxUSBFSConfigDscr
 1696 0e30 28030000 		.word	.LC16
 1697 0e34 00000000 		.word	CyFxUSBStringLangIDDscr
 1698 0e38 64030000 		.word	.LC17
 1699 0e3c 00000000 		.word	CyFxUSBManufactureDscr
 1700 0e40 00000000 		.word	CyFxUSBProductDscr
 1701 0e44 00000000 		.word	gl_UsbLogBuffer
 1702 0e48 98030000 		.word	.LC18
 1703 0e4c B8030000 		.word	.LC19
 1704 0e50 00000000 		.word	glIsApplnActive
 1705 0e54 E0030000 		.word	.LC20
 1706              		.cfi_endproc
 1707              	.LFE7:
 1709              		.section	.rodata
 1710              		.align	2
 1711              	.LC21:
 1712 0404 52656D6F 		.ascii	"Remote wake attempt failed with code: %d\015\012\000"
 1712      74652077 
 1712      616B6520 
 1712      61747465 
 1712      6D707420 
 1713 042f 00       		.align	2
 1714              	.LC22:
 1715 0430 55534220 		.ascii	"USB LOG: %x\015\012\000"
 1715      4C4F473A 
 1715      2025780D 
 1715      0A00
 1716              		.text
 1717              		.align	2
 1718              		.global	BulkSrcSinkAppThread_Entry
 1720              	BulkSrcSinkAppThread_Entry:
 1721              	.LFB8:
 771:../cyfxbulksrcsink.c **** 
 772:../cyfxbulksrcsink.c **** /* Entry function for the BulkSrcSinkAppThread. */
 773:../cyfxbulksrcsink.c **** void
 774:../cyfxbulksrcsink.c **** BulkSrcSinkAppThread_Entry (
 775:../cyfxbulksrcsink.c ****         uint32_t input)
 776:../cyfxbulksrcsink.c **** {
 1722              		.loc 1 776 0
 1723              		.cfi_startproc
 1724              		@ args = 0, pretend = 0, frame = 56
 1725              		@ frame_needed = 1, uses_anonymous_args = 0
 1726 0e58 00482DE9 		stmfd	sp!, {fp, lr}
 1727              	.LCFI16:
 1728              		.cfi_def_cfa_offset 8
 1729 0e5c 04B08DE2 		add	fp, sp, #4
 1730              		.cfi_offset 14, -4
 1731              		.cfi_offset 11, -8
 1732              	.LCFI17:
 1733              		.cfi_def_cfa 11, 4
 1734 0e60 40D04DE2 		sub	sp, sp, #64
 1735 0e64 38000BE5 		str	r0, [fp, #-56]
 777:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t stat;
 778:../cyfxbulksrcsink.c ****     uint32_t eventMask = CYFX_USB_CTRL_TASK | CYFX_USB_HOSTWAKE_TASK;   /* Mask representing events
 1736              		.loc 1 778 0
 1737 0e68 0330A0E3 		mov	r3, #3
 1738 0e6c 10300BE5 		str	r3, [fp, #-16]
 779:../cyfxbulksrcsink.c ****     uint32_t eventStat;                                                 /* Variable to hold current
 780:../cyfxbulksrcsink.c **** 
 781:../cyfxbulksrcsink.c ****     uint16_t prevUsbLogIndex = 0, tmp1, tmp2;
 1739              		.loc 1 781 0
 1740 0e70 0030A0E3 		mov	r3, #0
 1741 0e74 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 782:../cyfxbulksrcsink.c ****     CyU3PUsbLinkPowerMode curState;
 783:../cyfxbulksrcsink.c **** #if 0
 784:../cyfxbulksrcsink.c ****     /* Initialize the debug module */
 785:../cyfxbulksrcsink.c ****     CyFxBulkSrcSinkApplnDebugInit();
 786:../cyfxbulksrcsink.c ****     CyU3PDebugPrint (1, "\n\ndebug initialized\r\n");
 787:../cyfxbulksrcsink.c **** #endif
 788:../cyfxbulksrcsink.c ****     /* Initialize the application */
 789:../cyfxbulksrcsink.c ****     CyFxBulkSrcSinkApplnInit();
 1742              		.loc 1 789 0
 1743 0e78 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnInit
 1744              	.L128:
 790:../cyfxbulksrcsink.c **** 
 791:../cyfxbulksrcsink.c ****     for (;;)
 792:../cyfxbulksrcsink.c ****     {
 793:../cyfxbulksrcsink.c ****         /* The following call will block until at least one of the events enabled in eventMask is r
 794:../cyfxbulksrcsink.c ****            The eventStat variable will hold the events that were active at the time of returning fr
 795:../cyfxbulksrcsink.c ****            The CLEAR flag means that all events will be atomically cleared before this function ret
 796:../cyfxbulksrcsink.c ****           
 797:../cyfxbulksrcsink.c ****            We cause this event wait to time out every 10 milli-seconds, so that we can periodically
 798:../cyfxbulksrcsink.c ****            device out of low power modes.
 799:../cyfxbulksrcsink.c ****          */
 800:../cyfxbulksrcsink.c ****         stat = CyU3PEventGet (&glBulkLpEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventStat, 10);
 1745              		.loc 1 800 0
 1746 0e7c 24304BE2 		sub	r3, fp, #36
 1747 0e80 0A20A0E3 		mov	r2, #10
 1748 0e84 00208DE5 		str	r2, [sp, #0]
 1749 0e88 F8069FE5 		ldr	r0, .L129
 1750 0e8c 10101BE5 		ldr	r1, [fp, #-16]
 1751 0e90 0120A0E3 		mov	r2, #1
 1752 0e94 FEFFFFEB 		bl	_txe_event_flags_get
 1753 0e98 08000BE5 		str	r0, [fp, #-8]
 801:../cyfxbulksrcsink.c ****         if (stat == CY_U3P_SUCCESS)
 1754              		.loc 1 801 0
 1755 0e9c 08301BE5 		ldr	r3, [fp, #-8]
 1756 0ea0 000053E3 		cmp	r3, #0
 1757 0ea4 3D01001A 		bne	.L89
 802:../cyfxbulksrcsink.c ****         {
 803:../cyfxbulksrcsink.c ****             /* If the HOSTWAKE task is set, send a DEV_NOTIFICATION (FUNCTION_WAKE) or remote wakeu
 804:../cyfxbulksrcsink.c ****                based on the USB connection speed. */
 805:../cyfxbulksrcsink.c ****             if (eventStat & CYFX_USB_HOSTWAKE_TASK)
 1758              		.loc 1 805 0
 1759 0ea8 24301BE5 		ldr	r3, [fp, #-36]
 1760 0eac 023003E2 		and	r3, r3, #2
 1761 0eb0 000053E3 		cmp	r3, #0
 1762 0eb4 1400000A 		beq	.L90
 806:../cyfxbulksrcsink.c ****             {
 807:../cyfxbulksrcsink.c ****                 CyU3PThreadSleep (1000);
 1763              		.loc 1 807 0
 1764 0eb8 FA0FA0E3 		mov	r0, #1000
 1765 0ebc FEFFFFEB 		bl	_tx_thread_sleep
 808:../cyfxbulksrcsink.c ****                 if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1766              		.loc 1 808 0
 1767 0ec0 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1768 0ec4 0030A0E1 		mov	r3, r0
 1769 0ec8 030053E3 		cmp	r3, #3
 1770 0ecc 0500001A 		bne	.L91
 809:../cyfxbulksrcsink.c ****                     stat = CyU3PUsbSendDevNotification (1, 0, 0);
 1771              		.loc 1 809 0
 1772 0ed0 0100A0E3 		mov	r0, #1
 1773 0ed4 0010A0E3 		mov	r1, #0
 1774 0ed8 0020A0E3 		mov	r2, #0
 1775 0edc FEFFFFEB 		bl	CyU3PUsbSendDevNotification
 1776 0ee0 08000BE5 		str	r0, [fp, #-8]
 1777 0ee4 010000EA 		b	.L92
 1778              	.L91:
 810:../cyfxbulksrcsink.c ****                 else
 811:../cyfxbulksrcsink.c ****                     stat = CyU3PUsbDoRemoteWakeup ();
 1779              		.loc 1 811 0
 1780 0ee8 FEFFFFEB 		bl	CyU3PUsbDoRemoteWakeup
 1781 0eec 08000BE5 		str	r0, [fp, #-8]
 1782              	.L92:
 812:../cyfxbulksrcsink.c **** 
 813:../cyfxbulksrcsink.c ****                 if (stat != CY_U3P_SUCCESS)
 1783              		.loc 1 813 0
 1784 0ef0 08301BE5 		ldr	r3, [fp, #-8]
 1785 0ef4 000053E3 		cmp	r3, #0
 1786 0ef8 0300000A 		beq	.L90
 814:../cyfxbulksrcsink.c ****                     CyU3PDebugPrint (2, "Remote wake attempt failed with code: %d\r\n", stat);
 1787              		.loc 1 814 0
 1788 0efc 0200A0E3 		mov	r0, #2
 1789 0f00 84169FE5 		ldr	r1, .L129+4
 1790 0f04 08201BE5 		ldr	r2, [fp, #-8]
 1791 0f08 FEFFFFEB 		bl	CyU3PDebugPrint
 1792              	.L90:
 815:../cyfxbulksrcsink.c ****             }
 816:../cyfxbulksrcsink.c **** 
 817:../cyfxbulksrcsink.c ****             /* If there is a pending control request, handle it here. */
 818:../cyfxbulksrcsink.c ****             if (eventStat & CYFX_USB_CTRL_TASK)
 1793              		.loc 1 818 0
 1794 0f0c 24301BE5 		ldr	r3, [fp, #-36]
 1795 0f10 013003E2 		and	r3, r3, #1
 1796 0f14 FF3003E2 		and	r3, r3, #255
 1797 0f18 000053E3 		cmp	r3, #0
 1798 0f1c 1F01000A 		beq	.L89
 1799              	.LBB2:
 819:../cyfxbulksrcsink.c ****             {
 820:../cyfxbulksrcsink.c ****                 uint8_t  bRequest, bReqType;
 821:../cyfxbulksrcsink.c ****                 uint16_t wLength, temp;
 822:../cyfxbulksrcsink.c ****                 uint16_t wValue, wIndex;
 823:../cyfxbulksrcsink.c **** 
 824:../cyfxbulksrcsink.c ****                 /* Decode the fields from the setup request. */
 825:../cyfxbulksrcsink.c ****                 bReqType = (gl_setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
 1800              		.loc 1 825 0
 1801 0f20 68369FE5 		ldr	r3, .L129+8
 1802 0f24 003093E5 		ldr	r3, [r3, #0]
 1803 0f28 11304BE5 		strb	r3, [fp, #-17]
 826:../cyfxbulksrcsink.c ****                 bRequest = ((gl_setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
 1804              		.loc 1 826 0
 1805 0f2c 5C369FE5 		ldr	r3, .L129+8
 1806 0f30 003093E5 		ldr	r3, [r3, #0]
 1807 0f34 FF3C03E2 		and	r3, r3, #65280
 1808 0f38 2334A0E1 		mov	r3, r3, lsr #8
 1809 0f3c 12304BE5 		strb	r3, [fp, #-18]
 827:../cyfxbulksrcsink.c ****                 wLength  = ((gl_setupdat1 & CY_U3P_USB_LENGTH_MASK)  >> CY_U3P_USB_LENGTH_POS);
 1810              		.loc 1 827 0
 1811 0f40 4C369FE5 		ldr	r3, .L129+12
 1812 0f44 003093E5 		ldr	r3, [r3, #0]
 1813 0f48 2338A0E1 		mov	r3, r3, lsr #16
 1814 0f4c 0338A0E1 		mov	r3, r3, asl #16
 1815 0f50 2338A0E1 		mov	r3, r3, lsr #16
 1816 0f54 B8324BE1 		strh	r3, [fp, #-40]	@ movhi
 828:../cyfxbulksrcsink.c ****                 wValue   = ((gl_setupdat0 & CY_U3P_USB_VALUE_MASK) >> CY_U3P_USB_VALUE_POS);
 1817              		.loc 1 828 0
 1818 0f58 30369FE5 		ldr	r3, .L129+8
 1819 0f5c 003093E5 		ldr	r3, [r3, #0]
 1820 0f60 2338A0E1 		mov	r3, r3, lsr #16
 1821 0f64 B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 829:../cyfxbulksrcsink.c ****                 wIndex   = ((gl_setupdat1 & CY_U3P_USB_INDEX_MASK) >> CY_U3P_USB_INDEX_POS);
 1822              		.loc 1 829 0
 1823 0f68 24369FE5 		ldr	r3, .L129+12
 1824 0f6c 003093E5 		ldr	r3, [r3, #0]
 1825 0f70 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 830:../cyfxbulksrcsink.c **** 
 831:../cyfxbulksrcsink.c ****                 if ((bReqType & CY_U3P_USB_TYPE_MASK) == CY_U3P_USB_VENDOR_RQT)
 1826              		.loc 1 831 0
 1827 0f74 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 1828 0f78 603003E2 		and	r3, r3, #96
 1829 0f7c 400053E3 		cmp	r3, #64
 1830 0f80 0201001A 		bne	.L93
 832:../cyfxbulksrcsink.c ****                 {
 833:../cyfxbulksrcsink.c ****                     switch (bRequest)
 1831              		.loc 1 833 0
 1832 0f84 12305BE5 		ldrb	r3, [fp, #-18]	@ zero_extendqisi2
 1833 0f88 773043E2 		sub	r3, r3, #119
 1834 0f8c 6A0053E3 		cmp	r3, #106
 1835 0f90 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1836 0f94 F80000EA 		b	.L94
 1837              	.L106:
 1838 0f98 44110000 		.word	.L95
 1839 0f9c 5C110000 		.word	.L96
 1840 0fa0 80110000 		.word	.L97
 1841 0fa4 7C130000 		.word	.L94
 1842 0fa8 7C130000 		.word	.L94
 1843 0fac 7C130000 		.word	.L94
 1844 0fb0 7C130000 		.word	.L94
 1845 0fb4 7C130000 		.word	.L94
 1846 0fb8 7C130000 		.word	.L94
 1847 0fbc 90110000 		.word	.L98
 1848 0fc0 A8110000 		.word	.L99
 1849 0fc4 F8110000 		.word	.L100
 1850 0fc8 50120000 		.word	.L101
 1851 0fcc 8C120000 		.word	.L102
 1852 0fd0 7C130000 		.word	.L94
 1853 0fd4 7C130000 		.word	.L94
 1854 0fd8 7C130000 		.word	.L94
 1855 0fdc 7C130000 		.word	.L94
 1856 0fe0 7C130000 		.word	.L94
 1857 0fe4 7C130000 		.word	.L94
 1858 0fe8 7C130000 		.word	.L94
 1859 0fec 7C130000 		.word	.L94
 1860 0ff0 7C130000 		.word	.L94
 1861 0ff4 7C130000 		.word	.L94
 1862 0ff8 7C130000 		.word	.L94
 1863 0ffc FC120000 		.word	.L103
 1864 1000 7C130000 		.word	.L94
 1865 1004 7C130000 		.word	.L94
 1866 1008 7C130000 		.word	.L94
 1867 100c 7C130000 		.word	.L94
 1868 1010 7C130000 		.word	.L94
 1869 1014 7C130000 		.word	.L94
 1870 1018 7C130000 		.word	.L94
 1871 101c 7C130000 		.word	.L94
 1872 1020 7C130000 		.word	.L94
 1873 1024 7C130000 		.word	.L94
 1874 1028 7C130000 		.word	.L94
 1875 102c 7C130000 		.word	.L94
 1876 1030 7C130000 		.word	.L94
 1877 1034 7C130000 		.word	.L94
 1878 1038 7C130000 		.word	.L94
 1879 103c 7C130000 		.word	.L94
 1880 1040 7C130000 		.word	.L94
 1881 1044 7C130000 		.word	.L94
 1882 1048 7C130000 		.word	.L94
 1883 104c 7C130000 		.word	.L94
 1884 1050 7C130000 		.word	.L94
 1885 1054 7C130000 		.word	.L94
 1886 1058 7C130000 		.word	.L94
 1887 105c 7C130000 		.word	.L94
 1888 1060 7C130000 		.word	.L94
 1889 1064 7C130000 		.word	.L94
 1890 1068 7C130000 		.word	.L94
 1891 106c 7C130000 		.word	.L94
 1892 1070 7C130000 		.word	.L94
 1893 1074 7C130000 		.word	.L94
 1894 1078 7C130000 		.word	.L94
 1895 107c 7C130000 		.word	.L94
 1896 1080 7C130000 		.word	.L94
 1897 1084 7C130000 		.word	.L94
 1898 1088 7C130000 		.word	.L94
 1899 108c 7C130000 		.word	.L94
 1900 1090 7C130000 		.word	.L94
 1901 1094 7C130000 		.word	.L94
 1902 1098 7C130000 		.word	.L94
 1903 109c 7C130000 		.word	.L94
 1904 10a0 7C130000 		.word	.L94
 1905 10a4 7C130000 		.word	.L94
 1906 10a8 7C130000 		.word	.L94
 1907 10ac 7C130000 		.word	.L94
 1908 10b0 7C130000 		.word	.L94
 1909 10b4 7C130000 		.word	.L94
 1910 10b8 7C130000 		.word	.L94
 1911 10bc 7C130000 		.word	.L94
 1912 10c0 7C130000 		.word	.L94
 1913 10c4 7C130000 		.word	.L94
 1914 10c8 7C130000 		.word	.L94
 1915 10cc 7C130000 		.word	.L94
 1916 10d0 7C130000 		.word	.L94
 1917 10d4 7C130000 		.word	.L94
 1918 10d8 7C130000 		.word	.L94
 1919 10dc 7C130000 		.word	.L94
 1920 10e0 7C130000 		.word	.L94
 1921 10e4 7C130000 		.word	.L94
 1922 10e8 7C130000 		.word	.L94
 1923 10ec 7C130000 		.word	.L94
 1924 10f0 7C130000 		.word	.L94
 1925 10f4 7C130000 		.word	.L94
 1926 10f8 7C130000 		.word	.L94
 1927 10fc 7C130000 		.word	.L94
 1928 1100 7C130000 		.word	.L94
 1929 1104 7C130000 		.word	.L94
 1930 1108 7C130000 		.word	.L94
 1931 110c 7C130000 		.word	.L94
 1932 1110 7C130000 		.word	.L94
 1933 1114 7C130000 		.word	.L94
 1934 1118 7C130000 		.word	.L94
 1935 111c 7C130000 		.word	.L94
 1936 1120 7C130000 		.word	.L94
 1937 1124 7C130000 		.word	.L94
 1938 1128 7C130000 		.word	.L94
 1939 112c 7C130000 		.word	.L94
 1940 1130 7C130000 		.word	.L94
 1941 1134 7C130000 		.word	.L94
 1942 1138 7C130000 		.word	.L94
 1943 113c 30130000 		.word	.L104
 1944 1140 64130000 		.word	.L105
 1945              	.L95:
 834:../cyfxbulksrcsink.c ****                     {
 835:../cyfxbulksrcsink.c ****                     case 0x77:      /* Trigger remote wakeup. */
 836:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 1946              		.loc 1 836 0
 1947 1144 FEFFFFEB 		bl	CyU3PUsbAckSetup
 837:../cyfxbulksrcsink.c ****                         CyU3PEventSet (&glBulkLpEvent, CYFX_USB_HOSTWAKE_TASK, CYU3P_EVENT_OR);
 1948              		.loc 1 837 0
 1949 1148 38049FE5 		ldr	r0, .L129
 1950 114c 0210A0E3 		mov	r1, #2
 1951 1150 0020A0E3 		mov	r2, #0
 1952 1154 FEFFFFEB 		bl	_txe_event_flags_set
 838:../cyfxbulksrcsink.c ****                         break;
 1953              		.loc 1 838 0
 1954 1158 900000EA 		b	.L89
 1955              	.L96:
 839:../cyfxbulksrcsink.c **** 
 840:../cyfxbulksrcsink.c ****                     case 0x78:      /* Get count of EP0 status events received. */
 841:../cyfxbulksrcsink.c ****                         CyU3PMemCopy ((uint8_t *)glEp0Buffer, ((uint8_t *)&glEp0StatCount), 4);
 1956              		.loc 1 841 0
 1957 115c 34349FE5 		ldr	r3, .L129+16
 1958 1160 34049FE5 		ldr	r0, .L129+20
 1959 1164 0310A0E1 		mov	r1, r3
 1960 1168 0420A0E3 		mov	r2, #4
 1961 116c FEFFFFEB 		bl	CyU3PMemCopy
 842:../cyfxbulksrcsink.c ****                         CyU3PUsbSendEP0Data (4, glEp0Buffer);
 1962              		.loc 1 842 0
 1963 1170 0400A0E3 		mov	r0, #4
 1964 1174 20149FE5 		ldr	r1, .L129+20
 1965 1178 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 843:../cyfxbulksrcsink.c ****                         break;
 1966              		.loc 1 843 0
 1967 117c 870000EA 		b	.L89
 1968              	.L97:
 844:../cyfxbulksrcsink.c **** 
 845:../cyfxbulksrcsink.c ****                     case 0x79:      /* Request with no data phase. Insert a delay and then ACK the 
 846:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (5);
 1969              		.loc 1 846 0
 1970 1180 0500A0E3 		mov	r0, #5
 1971 1184 FEFFFFEB 		bl	_tx_thread_sleep
 847:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 1972              		.loc 1 847 0
 1973 1188 FEFFFFEB 		bl	CyU3PUsbAckSetup
 848:../cyfxbulksrcsink.c ****                         break;
 1974              		.loc 1 848 0
 1975 118c 830000EA 		b	.L89
 1976              	.L98:
 849:../cyfxbulksrcsink.c **** 
 850:../cyfxbulksrcsink.c ****                     case 0x80:      /* Request with OUT data phase. Just get the data and ignore it
 851:../cyfxbulksrcsink.c ****                         CyU3PUsbGetEP0Data (sizeof (glEp0Buffer), (uint8_t *)glEp0Buffer, &wLength)
 1977              		.loc 1 851 0
 1978 1190 28304BE2 		sub	r3, fp, #40
 1979 1194 2000A0E3 		mov	r0, #32
 1980 1198 FC139FE5 		ldr	r1, .L129+20
 1981 119c 0320A0E1 		mov	r2, r3
 1982 11a0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 852:../cyfxbulksrcsink.c ****                         break;
 1983              		.loc 1 852 0
 1984 11a4 7D0000EA 		b	.L89
 1985              	.L99:
 853:../cyfxbulksrcsink.c **** 
 854:../cyfxbulksrcsink.c ****                     case 0x81:
 855:../cyfxbulksrcsink.c ****                         /* Get the current event log index and send it to the host. */
 856:../cyfxbulksrcsink.c ****                         if (wLength == 2)
 1986              		.loc 1 856 0
 1987 11a8 B8325BE1 		ldrh	r3, [fp, #-40]
 1988 11ac 020053E3 		cmp	r3, #2
 1989 11b0 0B00001A 		bne	.L108
 857:../cyfxbulksrcsink.c ****                         {
 858:../cyfxbulksrcsink.c ****                             temp = CyU3PUsbGetEventLogIndex ();
 1990              		.loc 1 858 0
 1991 11b4 FEFFFFEB 		bl	CyU3PUsbGetEventLogIndex
 1992 11b8 0030A0E1 		mov	r3, r0
 1993 11bc BA324BE1 		strh	r3, [fp, #-42]	@ movhi
 859:../cyfxbulksrcsink.c ****                             CyU3PMemCopy ((uint8_t *)glEp0Buffer, (uint8_t *)&temp, 2);
 1994              		.loc 1 859 0
 1995 11c0 2A304BE2 		sub	r3, fp, #42
 1996 11c4 D0039FE5 		ldr	r0, .L129+20
 1997 11c8 0310A0E1 		mov	r1, r3
 1998 11cc 0220A0E3 		mov	r2, #2
 1999 11d0 FEFFFFEB 		bl	CyU3PMemCopy
 860:../cyfxbulksrcsink.c ****                             CyU3PUsbSendEP0Data (2, glEp0Buffer);
 2000              		.loc 1 860 0
 2001 11d4 0200A0E3 		mov	r0, #2
 2002 11d8 BC139FE5 		ldr	r1, .L129+20
 2003 11dc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 861:../cyfxbulksrcsink.c ****                         }
 862:../cyfxbulksrcsink.c ****                         else
 863:../cyfxbulksrcsink.c ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 864:../cyfxbulksrcsink.c ****                         break;
 2004              		.loc 1 864 0
 2005 11e0 6E0000EA 		b	.L89
 2006              	.L108:
 863:../cyfxbulksrcsink.c ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 2007              		.loc 1 863 0
 2008 11e4 0000A0E3 		mov	r0, #0
 2009 11e8 0110A0E3 		mov	r1, #1
 2010 11ec 0020A0E3 		mov	r2, #0
 2011 11f0 FEFFFFEB 		bl	CyU3PUsbStall
 2012              		.loc 1 864 0
 2013 11f4 690000EA 		b	.L89
 2014              	.L100:
 865:../cyfxbulksrcsink.c **** 
 866:../cyfxbulksrcsink.c ****                     case 0x82:
 867:../cyfxbulksrcsink.c ****                         /* Send the USB event log buffer content to the host. */
 868:../cyfxbulksrcsink.c ****                         if (wLength != 0)
 2015              		.loc 1 868 0
 2016 11f8 B8325BE1 		ldrh	r3, [fp, #-40]
 2017 11fc 000053E3 		cmp	r3, #0
 2018 1200 1000000A 		beq	.L110
 869:../cyfxbulksrcsink.c ****                         {
 870:../cyfxbulksrcsink.c ****                             if (wLength < CYFX_USBLOG_SIZE)
 2019              		.loc 1 870 0
 2020 1204 B8225BE1 		ldrh	r2, [fp, #-40]
 2021 1208 90339FE5 		ldr	r3, .L129+24
 2022 120c 030052E1 		cmp	r2, r3
 2023 1210 0600008A 		bhi	.L111
 871:../cyfxbulksrcsink.c ****                                 CyU3PUsbSendEP0Data (wLength, gl_UsbLogBuffer);
 2024              		.loc 1 871 0
 2025 1214 B8225BE1 		ldrh	r2, [fp, #-40]
 2026 1218 84339FE5 		ldr	r3, .L129+28
 2027 121c 003093E5 		ldr	r3, [r3, #0]
 2028 1220 0200A0E1 		mov	r0, r2
 2029 1224 0310A0E1 		mov	r1, r3
 2030 1228 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 872:../cyfxbulksrcsink.c ****                             else
 873:../cyfxbulksrcsink.c ****                                 CyU3PUsbSendEP0Data (CYFX_USBLOG_SIZE, gl_UsbLogBuffer);
 874:../cyfxbulksrcsink.c ****                         }
 875:../cyfxbulksrcsink.c ****                         else
 876:../cyfxbulksrcsink.c ****                             CyU3PUsbAckSetup ();
 877:../cyfxbulksrcsink.c ****                         break;
 2031              		.loc 1 877 0
 2032 122c 5B0000EA 		b	.L89
 2033              	.L111:
 873:../cyfxbulksrcsink.c ****                                 CyU3PUsbSendEP0Data (CYFX_USBLOG_SIZE, gl_UsbLogBuffer);
 2034              		.loc 1 873 0
 2035 1230 6C339FE5 		ldr	r3, .L129+28
 2036 1234 003093E5 		ldr	r3, [r3, #0]
 2037 1238 010AA0E3 		mov	r0, #4096
 2038 123c 0310A0E1 		mov	r1, r3
 2039 1240 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2040              		.loc 1 877 0
 2041 1244 550000EA 		b	.L89
 2042              	.L110:
 876:../cyfxbulksrcsink.c ****                             CyU3PUsbAckSetup ();
 2043              		.loc 1 876 0
 2044 1248 FEFFFFEB 		bl	CyU3PUsbAckSetup
 2045              		.loc 1 877 0
 2046 124c 530000EA 		b	.L89
 2047              	.L101:
 2048              	.LBB3:
 878:../cyfxbulksrcsink.c **** 
 879:../cyfxbulksrcsink.c ****                     case 0x83:
 880:../cyfxbulksrcsink.c ****                         {
 881:../cyfxbulksrcsink.c ****                             uint32_t addr = ((uint32_t)wValue << 16) | (uint32_t)wIndex;
 2049              		.loc 1 881 0
 2050 1250 B4315BE1 		ldrh	r3, [fp, #-20]
 2051 1254 0328A0E1 		mov	r2, r3, asl #16
 2052 1258 B6315BE1 		ldrh	r3, [fp, #-22]
 2053 125c 033082E1 		orr	r3, r2, r3
 2054 1260 1C300BE5 		str	r3, [fp, #-28]
 882:../cyfxbulksrcsink.c ****                             CyU3PReadDeviceRegisters ((uvint32_t *)addr, 1, (uint32_t *)glEp0Buffer
 2055              		.loc 1 882 0
 2056 1264 1C201BE5 		ldr	r2, [fp, #-28]
 2057 1268 2C339FE5 		ldr	r3, .L129+20
 2058 126c 0200A0E1 		mov	r0, r2
 2059 1270 0110A0E3 		mov	r1, #1
 2060 1274 0320A0E1 		mov	r2, r3
 2061 1278 FEFFFFEB 		bl	CyU3PReadDeviceRegisters
 883:../cyfxbulksrcsink.c ****                             CyU3PUsbSendEP0Data (4, glEp0Buffer);
 2062              		.loc 1 883 0
 2063 127c 0400A0E3 		mov	r0, #4
 2064 1280 14139FE5 		ldr	r1, .L129+20
 2065 1284 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2066              	.LBE3:
 884:../cyfxbulksrcsink.c ****                         }
 885:../cyfxbulksrcsink.c ****                         break;
 2067              		.loc 1 885 0
 2068 1288 440000EA 		b	.L89
 2069              	.L102:
 2070              	.LBB4:
 886:../cyfxbulksrcsink.c **** 
 887:../cyfxbulksrcsink.c ****                     case 0x84:
 888:../cyfxbulksrcsink.c ****                         {
 889:../cyfxbulksrcsink.c ****                             uint8_t major, minor, patch;
 890:../cyfxbulksrcsink.c **** 
 891:../cyfxbulksrcsink.c ****                             if (CyU3PUsbGetBooterVersion (&major, &minor, &patch) == CY_U3P_SUCCESS
 2071              		.loc 1 891 0
 2072 128c 2B104BE2 		sub	r1, fp, #43
 2073 1290 2C204BE2 		sub	r2, fp, #44
 2074 1294 2D304BE2 		sub	r3, fp, #45
 2075 1298 0100A0E1 		mov	r0, r1
 2076 129c 0210A0E1 		mov	r1, r2
 2077 12a0 0320A0E1 		mov	r2, r3
 2078 12a4 FEFFFFEB 		bl	CyU3PUsbGetBooterVersion
 2079 12a8 0030A0E1 		mov	r3, r0
 2080 12ac 000053E3 		cmp	r3, #0
 2081 12b0 0C00001A 		bne	.L113
 892:../cyfxbulksrcsink.c ****                             {
 893:../cyfxbulksrcsink.c ****                                 glEp0Buffer[0] = major;
 2082              		.loc 1 893 0
 2083 12b4 2B205BE5 		ldrb	r2, [fp, #-43]	@ zero_extendqisi2
 2084 12b8 DC329FE5 		ldr	r3, .L129+20
 2085 12bc 0020C3E5 		strb	r2, [r3, #0]
 894:../cyfxbulksrcsink.c ****                                 glEp0Buffer[1] = minor;
 2086              		.loc 1 894 0
 2087 12c0 2C205BE5 		ldrb	r2, [fp, #-44]	@ zero_extendqisi2
 2088 12c4 D0329FE5 		ldr	r3, .L129+20
 2089 12c8 0120C3E5 		strb	r2, [r3, #1]
 895:../cyfxbulksrcsink.c ****                                 glEp0Buffer[2] = patch;
 2090              		.loc 1 895 0
 2091 12cc 2D205BE5 		ldrb	r2, [fp, #-45]	@ zero_extendqisi2
 2092 12d0 C4329FE5 		ldr	r3, .L129+20
 2093 12d4 0220C3E5 		strb	r2, [r3, #2]
 896:../cyfxbulksrcsink.c ****                                 CyU3PUsbSendEP0Data (3, glEp0Buffer);
 2094              		.loc 1 896 0
 2095 12d8 0300A0E3 		mov	r0, #3
 2096 12dc B8129FE5 		ldr	r1, .L129+20
 2097 12e0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2098              	.LBE4:
 897:../cyfxbulksrcsink.c ****                             }
 898:../cyfxbulksrcsink.c ****                             else
 899:../cyfxbulksrcsink.c ****                                 CyU3PUsbStall (0, CyTrue, CyFalse);
 900:../cyfxbulksrcsink.c ****                         }
 901:../cyfxbulksrcsink.c ****                         break;
 2099              		.loc 1 901 0
 2100 12e4 2D0000EA 		b	.L89
 2101              	.L113:
 2102              	.LBB5:
 899:../cyfxbulksrcsink.c ****                                 CyU3PUsbStall (0, CyTrue, CyFalse);
 2103              		.loc 1 899 0
 2104 12e8 0000A0E3 		mov	r0, #0
 2105 12ec 0110A0E3 		mov	r1, #1
 2106 12f0 0020A0E3 		mov	r2, #0
 2107 12f4 FEFFFFEB 		bl	CyU3PUsbStall
 2108              	.LBE5:
 2109              		.loc 1 901 0
 2110 12f8 280000EA 		b	.L89
 2111              	.L103:
 902:../cyfxbulksrcsink.c **** 
 903:../cyfxbulksrcsink.c ****                     case 0x90:
 904:../cyfxbulksrcsink.c ****                         /* Request to switch control back to the boot firmware. */
 905:../cyfxbulksrcsink.c **** 
 906:../cyfxbulksrcsink.c ****                         /* Complete the control request. */
 907:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 2112              		.loc 1 907 0
 2113 12fc FEFFFFEB 		bl	CyU3PUsbAckSetup
 908:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (10);
 2114              		.loc 1 908 0
 2115 1300 0A00A0E3 		mov	r0, #10
 2116 1304 FEFFFFEB 		bl	_tx_thread_sleep
 909:../cyfxbulksrcsink.c **** 
 910:../cyfxbulksrcsink.c ****                         /* Get rid of the DMA channels and EP configuration. */
 911:../cyfxbulksrcsink.c ****                         CyFxBulkSrcSinkApplnStop ();
 2117              		.loc 1 911 0
 2118 1308 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStop
 912:../cyfxbulksrcsink.c **** 
 913:../cyfxbulksrcsink.c ****                         /* De-initialize the Debug and UART modules. */
 914:../cyfxbulksrcsink.c ****                         CyU3PDebugDeInit ();
 2119              		.loc 1 914 0
 2120 130c FEFFFFEB 		bl	CyU3PDebugDeInit
 915:../cyfxbulksrcsink.c ****                         CyU3PUartDeInit ();
 2121              		.loc 1 915 0
 2122 1310 FEFFFFEB 		bl	CyU3PUartDeInit
 916:../cyfxbulksrcsink.c **** 
 917:../cyfxbulksrcsink.c ****                         /* Now jump back to the boot firmware image. */
 918:../cyfxbulksrcsink.c ****                         CyU3PUsbSetBooterSwitch (CyTrue);
 2123              		.loc 1 918 0
 2124 1314 0100A0E3 		mov	r0, #1
 2125 1318 FEFFFFEB 		bl	CyU3PUsbSetBooterSwitch
 919:../cyfxbulksrcsink.c ****                         CyU3PUsbJumpBackToBooter (0x40078000);
 2126              		.loc 1 919 0
 2127 131c 84029FE5 		ldr	r0, .L129+32
 2128 1320 FEFFFFEB 		bl	CyU3PUsbJumpBackToBooter
 2129              	.L115:
 920:../cyfxbulksrcsink.c ****                         while (1)
 921:../cyfxbulksrcsink.c ****                             CyU3PThreadSleep (100);
 2130              		.loc 1 921 0 discriminator 1
 2131 1324 6400A0E3 		mov	r0, #100
 2132 1328 FEFFFFEB 		bl	_tx_thread_sleep
 2133 132c FCFFFFEA 		b	.L115
 2134              	.L104:
 922:../cyfxbulksrcsink.c ****                         break;
 923:../cyfxbulksrcsink.c **** 
 924:../cyfxbulksrcsink.c ****                     case 0xE0:
 925:../cyfxbulksrcsink.c ****                         /* Request to reset the FX3 device. */
 926:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 2135              		.loc 1 926 0
 2136 1330 FEFFFFEB 		bl	CyU3PUsbAckSetup
 927:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (2000);
 2137              		.loc 1 927 0
 2138 1334 7D0EA0E3 		mov	r0, #2000
 2139 1338 FEFFFFEB 		bl	_tx_thread_sleep
 928:../cyfxbulksrcsink.c ****                         CyU3PConnectState (CyFalse, CyTrue);
 2140              		.loc 1 928 0
 2141 133c 0000A0E3 		mov	r0, #0
 2142 1340 0110A0E3 		mov	r1, #1
 2143 1344 FEFFFFEB 		bl	CyU3PConnectState
 929:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (1000);
 2144              		.loc 1 929 0
 2145 1348 FA0FA0E3 		mov	r0, #1000
 2146 134c FEFFFFEB 		bl	_tx_thread_sleep
 930:../cyfxbulksrcsink.c ****                         CyU3PDeviceReset (CyFalse);
 2147              		.loc 1 930 0
 2148 1350 0000A0E3 		mov	r0, #0
 2149 1354 FEFFFFEB 		bl	CyU3PDeviceReset
 931:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (1000);
 2150              		.loc 1 931 0
 2151 1358 FA0FA0E3 		mov	r0, #1000
 2152 135c FEFFFFEB 		bl	_tx_thread_sleep
 932:../cyfxbulksrcsink.c ****                         break;
 2153              		.loc 1 932 0
 2154 1360 0E0000EA 		b	.L89
 2155              	.L105:
 933:../cyfxbulksrcsink.c **** 
 934:../cyfxbulksrcsink.c ****                     case 0xE1:
 935:../cyfxbulksrcsink.c ****                         /* Request to place FX3 in standby when VBus is next disconnected. */
 936:../cyfxbulksrcsink.c ****                         StandbyModeEnable = CyTrue;
 2156              		.loc 1 936 0
 2157 1364 40329FE5 		ldr	r3, .L129+36
 2158 1368 0120A0E3 		mov	r2, #1
 2159 136c 002083E5 		str	r2, [r3, #0]
 937:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 2160              		.loc 1 937 0
 2161 1370 FEFFFFEB 		bl	CyU3PUsbAckSetup
 938:../cyfxbulksrcsink.c ****                         break;
 2162              		.loc 1 938 0
 2163 1374 0000A0E1 		mov	r0, r0	@ nop
 2164 1378 080000EA 		b	.L89
 2165              	.L94:
 939:../cyfxbulksrcsink.c **** 
 940:../cyfxbulksrcsink.c ****                     default:        /* Unknown request. Stall EP0. */
 941:../cyfxbulksrcsink.c ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 2166              		.loc 1 941 0
 2167 137c 0000A0E3 		mov	r0, #0
 2168 1380 0110A0E3 		mov	r1, #1
 2169 1384 0020A0E3 		mov	r2, #0
 2170 1388 FEFFFFEB 		bl	CyU3PUsbStall
 942:../cyfxbulksrcsink.c ****                         break;
 2171              		.loc 1 942 0
 2172 138c 030000EA 		b	.L89
 2173              	.L93:
 943:../cyfxbulksrcsink.c ****                     }
 944:../cyfxbulksrcsink.c ****                 }
 945:../cyfxbulksrcsink.c ****                 else
 946:../cyfxbulksrcsink.c ****                 {
 947:../cyfxbulksrcsink.c ****                     /* Only vendor requests are to be handled here. */
 948:../cyfxbulksrcsink.c ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
 2174              		.loc 1 948 0
 2175 1390 0000A0E3 		mov	r0, #0
 2176 1394 0110A0E3 		mov	r1, #1
 2177 1398 0020A0E3 		mov	r2, #0
 2178 139c FEFFFFEB 		bl	CyU3PUsbStall
 2179              	.L89:
 2180              	.LBE2:
 949:../cyfxbulksrcsink.c ****                 }
 950:../cyfxbulksrcsink.c ****             }
 951:../cyfxbulksrcsink.c ****         }
 952:../cyfxbulksrcsink.c **** 
 953:../cyfxbulksrcsink.c ****         /* Try to get the USB 3.0 link back to U0. */
 954:../cyfxbulksrcsink.c ****         if (glForceLinkU2)
 2181              		.loc 1 954 0
 2182 13a0 08329FE5 		ldr	r3, .L129+40
 2183 13a4 003093E5 		ldr	r3, [r3, #0]
 2184 13a8 000053E3 		cmp	r3, #0
 2185 13ac 1700000A 		beq	.L116
 955:../cyfxbulksrcsink.c ****         {
 956:../cyfxbulksrcsink.c ****             stat = CyU3PUsbGetLinkPowerState (&curState);
 2186              		.loc 1 956 0
 2187 13b0 25304BE2 		sub	r3, fp, #37
 2188 13b4 0300A0E1 		mov	r0, r3
 2189 13b8 FEFFFFEB 		bl	CyU3PUsbGetLinkPowerState
 2190 13bc 08000BE5 		str	r0, [fp, #-8]
 957:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2191              		.loc 1 957 0
 2192 13c0 070000EA 		b	.L117
 2193              	.L119:
 958:../cyfxbulksrcsink.c ****             {
 959:../cyfxbulksrcsink.c ****                 /* Repeatedly try to go into U2 state.*/
 960:../cyfxbulksrcsink.c ****                 CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U2);
 2194              		.loc 1 960 0
 2195 13c4 0200A0E3 		mov	r0, #2
 2196 13c8 FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 961:../cyfxbulksrcsink.c ****                 CyU3PThreadSleep (5);
 2197              		.loc 1 961 0
 2198 13cc 0500A0E3 		mov	r0, #5
 2199 13d0 FEFFFFEB 		bl	_tx_thread_sleep
 962:../cyfxbulksrcsink.c ****                 stat = CyU3PUsbGetLinkPowerState (&curState);
 2200              		.loc 1 962 0
 2201 13d4 25304BE2 		sub	r3, fp, #37
 2202 13d8 0300A0E1 		mov	r0, r3
 2203 13dc FEFFFFEB 		bl	CyU3PUsbGetLinkPowerState
 2204 13e0 08000BE5 		str	r0, [fp, #-8]
 2205              	.L117:
 957:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2206              		.loc 1 957 0 discriminator 1
 2207 13e4 C4319FE5 		ldr	r3, .L129+40
 2208 13e8 003093E5 		ldr	r3, [r3, #0]
 2209 13ec 000053E3 		cmp	r3, #0
 2210 13f0 2800000A 		beq	.L118
 957:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2211              		.loc 1 957 0 is_stmt 0 discriminator 2
 2212 13f4 08301BE5 		ldr	r3, [fp, #-8]
 2213 13f8 000053E3 		cmp	r3, #0
 2214 13fc 2500001A 		bne	.L118
 957:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2215              		.loc 1 957 0 discriminator 1
 2216 1400 25305BE5 		ldrb	r3, [fp, #-37]	@ zero_extendqisi2
 2217 1404 000053E3 		cmp	r3, #0
 2218 1408 EDFFFF0A 		beq	.L119
 957:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2219              		.loc 1 957 0
 2220 140c 210000EA 		b	.L118
 2221              	.L116:
 963:../cyfxbulksrcsink.c ****             }
 964:../cyfxbulksrcsink.c ****         }
 965:../cyfxbulksrcsink.c ****         else
 966:../cyfxbulksrcsink.c ****         {
 967:../cyfxbulksrcsink.c **** 
 968:../cyfxbulksrcsink.c ****             /* Once data transfer has started, we keep trying to get the USB link to stay in U0. If
 969:../cyfxbulksrcsink.c ****                before data transfers have started, there is a likelihood of failing the TD 9.24 U1/
 970:../cyfxbulksrcsink.c ****             if ((CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED) && (glDataTransStarted))
 2222              		.loc 1 970 0 is_stmt 1
 2223 1410 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 2224 1414 0030A0E1 		mov	r3, r0
 2225 1418 030053E3 		cmp	r3, #3
 2226 141c 1D00001A 		bne	.L118
 2227              		.loc 1 970 0 is_stmt 0 discriminator 1
 2228 1420 8C319FE5 		ldr	r3, .L129+44
 2229 1424 003093E5 		ldr	r3, [r3, #0]
 2230 1428 000053E3 		cmp	r3, #0
 2231 142c 1900000A 		beq	.L118
 971:../cyfxbulksrcsink.c ****             {
 972:../cyfxbulksrcsink.c ****                 /* If the link is in U1/U2 states, try to get back to U0. */
 973:../cyfxbulksrcsink.c ****                 stat = CyU3PUsbGetLinkPowerState (&curState);
 2232              		.loc 1 973 0 is_stmt 1
 2233 1430 25304BE2 		sub	r3, fp, #37
 2234 1434 0300A0E1 		mov	r0, r3
 2235 1438 FEFFFFEB 		bl	CyU3PUsbGetLinkPowerState
 2236 143c 08000BE5 		str	r0, [fp, #-8]
 974:../cyfxbulksrcsink.c ****                 while ((stat == CY_U3P_SUCCESS) && (curState >= CyU3PUsbLPM_U1) && (curState <= CyU
 2237              		.loc 1 974 0
 2238 1440 070000EA 		b	.L120
 2239              	.L121:
 975:../cyfxbulksrcsink.c ****                         (glDataTransStarted))
 976:../cyfxbulksrcsink.c ****                 {
 977:../cyfxbulksrcsink.c ****                     CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U0);
 2240              		.loc 1 977 0
 2241 1444 0000A0E3 		mov	r0, #0
 2242 1448 FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 978:../cyfxbulksrcsink.c ****                     CyU3PThreadSleep (1);
 2243              		.loc 1 978 0
 2244 144c 0100A0E3 		mov	r0, #1
 2245 1450 FEFFFFEB 		bl	_tx_thread_sleep
 979:../cyfxbulksrcsink.c ****                     stat = CyU3PUsbGetLinkPowerState (&curState);
 2246              		.loc 1 979 0
 2247 1454 25304BE2 		sub	r3, fp, #37
 2248 1458 0300A0E1 		mov	r0, r3
 2249 145c FEFFFFEB 		bl	CyU3PUsbGetLinkPowerState
 2250 1460 08000BE5 		str	r0, [fp, #-8]
 2251              	.L120:
 974:../cyfxbulksrcsink.c ****                 while ((stat == CY_U3P_SUCCESS) && (curState >= CyU3PUsbLPM_U1) && (curState <= CyU
 2252              		.loc 1 974 0 discriminator 1
 2253 1464 08301BE5 		ldr	r3, [fp, #-8]
 2254 1468 000053E3 		cmp	r3, #0
 2255 146c 0900001A 		bne	.L118
 974:../cyfxbulksrcsink.c ****                 while ((stat == CY_U3P_SUCCESS) && (curState >= CyU3PUsbLPM_U1) && (curState <= CyU
 2256              		.loc 1 974 0 is_stmt 0 discriminator 2
 2257 1470 25305BE5 		ldrb	r3, [fp, #-37]	@ zero_extendqisi2
 2258 1474 000053E3 		cmp	r3, #0
 2259 1478 0600000A 		beq	.L118
 974:../cyfxbulksrcsink.c ****                 while ((stat == CY_U3P_SUCCESS) && (curState >= CyU3PUsbLPM_U1) && (curState <= CyU
 2260              		.loc 1 974 0 discriminator 1
 2261 147c 25305BE5 		ldrb	r3, [fp, #-37]	@ zero_extendqisi2
 2262 1480 030053E3 		cmp	r3, #3
 2263 1484 0300008A 		bhi	.L118
 2264 1488 24319FE5 		ldr	r3, .L129+44
 2265 148c 003093E5 		ldr	r3, [r3, #0]
 2266 1490 000053E3 		cmp	r3, #0
 2267 1494 EAFFFF1A 		bne	.L121
 2268              	.L118:
 980:../cyfxbulksrcsink.c ****                 }
 981:../cyfxbulksrcsink.c ****             }
 982:../cyfxbulksrcsink.c ****         }
 983:../cyfxbulksrcsink.c **** 
 984:../cyfxbulksrcsink.c ****         if (TriggerStandbyMode)
 2269              		.loc 1 984 0 is_stmt 1
 2270 1498 18319FE5 		ldr	r3, .L129+48
 2271 149c 003093E5 		ldr	r3, [r3, #0]
 2272 14a0 000053E3 		cmp	r3, #0
 2273 14a4 1500000A 		beq	.L122
 985:../cyfxbulksrcsink.c ****         {
 986:../cyfxbulksrcsink.c ****             TriggerStandbyMode = CyFalse;
 2274              		.loc 1 986 0
 2275 14a8 08319FE5 		ldr	r3, .L129+48
 2276 14ac 0020A0E3 		mov	r2, #0
 2277 14b0 002083E5 		str	r2, [r3, #0]
 987:../cyfxbulksrcsink.c **** 
 988:../cyfxbulksrcsink.c ****             CyU3PConnectState (CyFalse, CyTrue);
 2278              		.loc 1 988 0
 2279 14b4 0000A0E3 		mov	r0, #0
 2280 14b8 0110A0E3 		mov	r1, #1
 2281 14bc FEFFFFEB 		bl	CyU3PConnectState
 989:../cyfxbulksrcsink.c ****             CyU3PUsbStop ();
 2282              		.loc 1 989 0
 2283 14c0 FEFFFFEB 		bl	CyU3PUsbStop
 990:../cyfxbulksrcsink.c ****             CyU3PDebugDeInit ();
 2284              		.loc 1 990 0
 2285 14c4 FEFFFFEB 		bl	CyU3PDebugDeInit
 991:../cyfxbulksrcsink.c ****             CyU3PUartDeInit ();
 2286              		.loc 1 991 0
 2287 14c8 FEFFFFEB 		bl	CyU3PUartDeInit
 992:../cyfxbulksrcsink.c **** 
 993:../cyfxbulksrcsink.c ****             /* VBus has been turned off. Go into standby mode and wait for VBus to be turned on aga
 994:../cyfxbulksrcsink.c ****                The I-TCM content and GPIO register state will be backed up in the memory area start
 995:../cyfxbulksrcsink.c ****                at address 0x40060000. */
 996:../cyfxbulksrcsink.c ****             stat = CyU3PSysEnterStandbyMode (CY_U3P_SYS_USB_VBUS_WAKEUP_SRC, CY_U3P_SYS_USB_VBUS_WA
 2288              		.loc 1 996 0
 2289 14cc 0400A0E3 		mov	r0, #4
 2290 14d0 0410A0E3 		mov	r1, #4
 2291 14d4 E0209FE5 		ldr	r2, .L129+52
 2292 14d8 FEFFFFEB 		bl	CyU3PSysEnterStandbyMode
 2293 14dc 08000BE5 		str	r0, [fp, #-8]
 997:../cyfxbulksrcsink.c ****                     (uint8_t *)0x40060000);
 998:../cyfxbulksrcsink.c ****             if (stat != CY_U3P_SUCCESS)
 2294              		.loc 1 998 0
 2295 14e0 08301BE5 		ldr	r3, [fp, #-8]
 2296 14e4 000053E3 		cmp	r3, #0
 2297 14e8 0100000A 		beq	.L123
 999:../cyfxbulksrcsink.c ****             {
1000:../cyfxbulksrcsink.c ****                 //CyFxBulkSrcSinkApplnDebugInit ();
1001:../cyfxbulksrcsink.c ****                 //CyU3PDebugPrint (4, "Enter standby returned %d\r\n", stat);
1002:../cyfxbulksrcsink.c ****                 CyFxAppErrorHandler (stat);
 2298              		.loc 1 1002 0
 2299 14ec 08001BE5 		ldr	r0, [fp, #-8]
 2300 14f0 FEFFFFEB 		bl	CyFxAppErrorHandler
 2301              	.L123:
1003:../cyfxbulksrcsink.c ****             }
1004:../cyfxbulksrcsink.c **** 
1005:../cyfxbulksrcsink.c ****             /* If the entry into standby succeeds, the CyU3PSysEnterStandbyMode function never retu
1006:../cyfxbulksrcsink.c ****                firmware application starts running again from the main entry point. Therefore, this
1007:../cyfxbulksrcsink.c ****                will never be executed. */
1008:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler (1);
 2302              		.loc 1 1008 0
 2303 14f4 0100A0E3 		mov	r0, #1
 2304 14f8 FEFFFFEB 		bl	CyFxAppErrorHandler
1009:../cyfxbulksrcsink.c ****         }
1010:../cyfxbulksrcsink.c ****         else
1011:../cyfxbulksrcsink.c ****         {
1012:../cyfxbulksrcsink.c ****             /* Compare the current USB driver log index against the previous value. */
1013:../cyfxbulksrcsink.c ****             tmp1 = CyU3PUsbGetEventLogIndex ();
1014:../cyfxbulksrcsink.c ****             if (tmp1 != prevUsbLogIndex)
1015:../cyfxbulksrcsink.c ****             {
1016:../cyfxbulksrcsink.c ****                 tmp2 = prevUsbLogIndex;
1017:../cyfxbulksrcsink.c ****                 while (tmp2 != tmp1)
1018:../cyfxbulksrcsink.c ****                 {
1019:../cyfxbulksrcsink.c ****                     CyU3PDebugPrint (4, "USB LOG: %x\r\n", gl_UsbLogBuffer[tmp2]);
1020:../cyfxbulksrcsink.c ****                     tmp2++;
1021:../cyfxbulksrcsink.c ****                     if (tmp2 == CYFX_USBLOG_SIZE)
1022:../cyfxbulksrcsink.c ****                         tmp2 = 0;
1023:../cyfxbulksrcsink.c ****                 }
1024:../cyfxbulksrcsink.c ****             }
1025:../cyfxbulksrcsink.c **** 
1026:../cyfxbulksrcsink.c ****             /* Store the current log index. */
1027:../cyfxbulksrcsink.c ****             prevUsbLogIndex = tmp1;
1028:../cyfxbulksrcsink.c ****         }
1029:../cyfxbulksrcsink.c ****     }
 2305              		.loc 1 1029 0
 2306 14fc 5EFEFFEA 		b	.L128
 2307              	.L122:
1013:../cyfxbulksrcsink.c ****             tmp1 = CyU3PUsbGetEventLogIndex ();
 2308              		.loc 1 1013 0
 2309 1500 FEFFFFEB 		bl	CyU3PUsbGetEventLogIndex
 2310 1504 0030A0E1 		mov	r3, r0
 2311 1508 BE314BE1 		strh	r3, [fp, #-30]	@ movhi
1014:../cyfxbulksrcsink.c ****             if (tmp1 != prevUsbLogIndex)
 2312              		.loc 1 1014 0
 2313 150c BE215BE1 		ldrh	r2, [fp, #-30]
 2314 1510 BA305BE1 		ldrh	r3, [fp, #-10]
 2315 1514 030052E1 		cmp	r2, r3
 2316 1518 1700000A 		beq	.L125
1016:../cyfxbulksrcsink.c ****                 tmp2 = prevUsbLogIndex;
 2317              		.loc 1 1016 0
 2318 151c BA305BE1 		ldrh	r3, [fp, #-10]	@ movhi
 2319 1520 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1017:../cyfxbulksrcsink.c ****                 while (tmp2 != tmp1)
 2320              		.loc 1 1017 0
 2321 1524 100000EA 		b	.L126
 2322              	.L127:
1019:../cyfxbulksrcsink.c ****                     CyU3PDebugPrint (4, "USB LOG: %x\r\n", gl_UsbLogBuffer[tmp2]);
 2323              		.loc 1 1019 0
 2324 1528 74309FE5 		ldr	r3, .L129+28
 2325 152c 002093E5 		ldr	r2, [r3, #0]
 2326 1530 BC305BE1 		ldrh	r3, [fp, #-12]
 2327 1534 033082E0 		add	r3, r2, r3
 2328 1538 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2329 153c 0400A0E3 		mov	r0, #4
 2330 1540 78109FE5 		ldr	r1, .L129+56
 2331 1544 0320A0E1 		mov	r2, r3
 2332 1548 FEFFFFEB 		bl	CyU3PDebugPrint
1020:../cyfxbulksrcsink.c ****                     tmp2++;
 2333              		.loc 1 1020 0
 2334 154c BC305BE1 		ldrh	r3, [fp, #-12]	@ movhi
 2335 1550 013083E2 		add	r3, r3, #1
 2336 1554 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
1021:../cyfxbulksrcsink.c ****                     if (tmp2 == CYFX_USBLOG_SIZE)
 2337              		.loc 1 1021 0
 2338 1558 BC305BE1 		ldrh	r3, [fp, #-12]
 2339 155c 010A53E3 		cmp	r3, #4096
 2340 1560 0100001A 		bne	.L126
1022:../cyfxbulksrcsink.c ****                         tmp2 = 0;
 2341              		.loc 1 1022 0
 2342 1564 0030A0E3 		mov	r3, #0
 2343 1568 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
 2344              	.L126:
1017:../cyfxbulksrcsink.c ****                 while (tmp2 != tmp1)
 2345              		.loc 1 1017 0 discriminator 1
 2346 156c BC205BE1 		ldrh	r2, [fp, #-12]
 2347 1570 BE315BE1 		ldrh	r3, [fp, #-30]
 2348 1574 030052E1 		cmp	r2, r3
 2349 1578 EAFFFF1A 		bne	.L127
 2350              	.L125:
1027:../cyfxbulksrcsink.c ****             prevUsbLogIndex = tmp1;
 2351              		.loc 1 1027 0
 2352 157c BE315BE1 		ldrh	r3, [fp, #-30]	@ movhi
 2353 1580 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 2354              		.loc 1 1029 0
 2355 1584 3CFEFFEA 		b	.L128
 2356              	.L130:
 2357              		.align	2
 2358              	.L129:
 2359 1588 00000000 		.word	glBulkLpEvent
 2360 158c 04040000 		.word	.LC21
 2361 1590 00000000 		.word	gl_setupdat0
 2362 1594 00000000 		.word	gl_setupdat1
 2363 1598 00000000 		.word	glEp0StatCount
 2364 159c 00000000 		.word	glEp0Buffer
 2365 15a0 FF0F0000 		.word	4095
 2366 15a4 00000000 		.word	gl_UsbLogBuffer
 2367 15a8 00800740 		.word	1074233344
 2368 15ac 00000000 		.word	StandbyModeEnable
 2369 15b0 00000000 		.word	glForceLinkU2
 2370 15b4 00000000 		.word	glDataTransStarted
 2371 15b8 00000000 		.word	TriggerStandbyMode
 2372 15bc 00000640 		.word	1074135040
 2373 15c0 30040000 		.word	.LC22
 2374              		.cfi_endproc
 2375              	.LFE8:
 2377              		.section	.rodata
 2378 043e 0000     		.align	2
 2379              	.LC23:
 2380 0440 32313A42 		.ascii	"21:Bulk_src_sink\000"
 2380      756C6B5F 
 2380      7372635F 
 2380      73696E6B 
 2380      00
 2381 0451 000000   		.text
 2382              		.align	2
 2383              		.global	CyFxApplicationDefine
 2385              	CyFxApplicationDefine:
 2386              	.LFB9:
1030:../cyfxbulksrcsink.c **** }
1031:../cyfxbulksrcsink.c **** 
1032:../cyfxbulksrcsink.c **** /* Application define function which creates the threads. */
1033:../cyfxbulksrcsink.c **** void
1034:../cyfxbulksrcsink.c **** CyFxApplicationDefine (
1035:../cyfxbulksrcsink.c ****         void)
1036:../cyfxbulksrcsink.c **** {
 2387              		.loc 1 1036 0
 2388              		.cfi_startproc
 2389              		@ args = 0, pretend = 0, frame = 8
 2390              		@ frame_needed = 1, uses_anonymous_args = 0
 2391 15c4 00482DE9 		stmfd	sp!, {fp, lr}
 2392              	.LCFI18:
 2393              		.cfi_def_cfa_offset 8
 2394 15c8 04B08DE2 		add	fp, sp, #4
 2395              		.cfi_offset 14, -4
 2396              		.cfi_offset 11, -8
 2397              	.LCFI19:
 2398              		.cfi_def_cfa 11, 4
 2399 15cc 28D04DE2 		sub	sp, sp, #40
1037:../cyfxbulksrcsink.c ****     void *ptr = NULL;
 2400              		.loc 1 1037 0
 2401 15d0 0030A0E3 		mov	r3, #0
 2402 15d4 08300BE5 		str	r3, [fp, #-8]
1038:../cyfxbulksrcsink.c ****     uint32_t ret = CY_U3P_SUCCESS;
 2403              		.loc 1 1038 0
 2404 15d8 0030A0E3 		mov	r3, #0
 2405 15dc 0C300BE5 		str	r3, [fp, #-12]
1039:../cyfxbulksrcsink.c **** 
1040:../cyfxbulksrcsink.c ****     /* Create an event flag group that will be used for signalling the application thread. */
1041:../cyfxbulksrcsink.c ****     ret = CyU3PEventCreate (&glBulkLpEvent);
 2406              		.loc 1 1041 0
 2407 15e0 90009FE5 		ldr	r0, .L136
 2408 15e4 0010A0E3 		mov	r1, #0
 2409 15e8 2820A0E3 		mov	r2, #40
 2410 15ec FEFFFFEB 		bl	_txe_event_flags_create
 2411 15f0 0C000BE5 		str	r0, [fp, #-12]
1042:../cyfxbulksrcsink.c ****     if (ret != 0)
 2412              		.loc 1 1042 0
 2413 15f4 0C301BE5 		ldr	r3, [fp, #-12]
 2414 15f8 000053E3 		cmp	r3, #0
 2415 15fc 0000000A 		beq	.L132
 2416              	.L133:
1043:../cyfxbulksrcsink.c ****     {
1044:../cyfxbulksrcsink.c ****         /* Loop indefinitely */
1045:../cyfxbulksrcsink.c ****         while (1);
 2417              		.loc 1 1045 0 discriminator 1
 2418 1600 FEFFFFEA 		b	.L133
 2419              	.L132:
1046:../cyfxbulksrcsink.c ****     }
1047:../cyfxbulksrcsink.c **** 
1048:../cyfxbulksrcsink.c ****     /* Allocate the memory for the threads */
1049:../cyfxbulksrcsink.c ****     ptr = CyU3PMemAlloc (CY_FX_BULKSRCSINK_THREAD_STACK);
 2420              		.loc 1 1049 0
 2421 1604 010AA0E3 		mov	r0, #4096
 2422 1608 FEFFFFEB 		bl	CyU3PMemAlloc
 2423 160c 08000BE5 		str	r0, [fp, #-8]
1050:../cyfxbulksrcsink.c **** 
1051:../cyfxbulksrcsink.c ****     /* Create the thread for the application */
1052:../cyfxbulksrcsink.c ****     ret = CyU3PThreadCreate (&bulkSrcSinkAppThread,                /* App thread structure */
 2424              		.loc 1 1052 0
 2425 1610 08301BE5 		ldr	r3, [fp, #-8]
 2426 1614 00308DE5 		str	r3, [sp, #0]
 2427 1618 013AA0E3 		mov	r3, #4096
 2428 161c 04308DE5 		str	r3, [sp, #4]
 2429 1620 0830A0E3 		mov	r3, #8
 2430 1624 08308DE5 		str	r3, [sp, #8]
 2431 1628 0830A0E3 		mov	r3, #8
 2432 162c 0C308DE5 		str	r3, [sp, #12]
 2433 1630 0030A0E3 		mov	r3, #0
 2434 1634 10308DE5 		str	r3, [sp, #16]
 2435 1638 0130A0E3 		mov	r3, #1
 2436 163c 14308DE5 		str	r3, [sp, #20]
 2437 1640 A830A0E3 		mov	r3, #168
 2438 1644 18308DE5 		str	r3, [sp, #24]
 2439 1648 2C009FE5 		ldr	r0, .L136+4
 2440 164c 2C109FE5 		ldr	r1, .L136+8
 2441 1650 2C209FE5 		ldr	r2, .L136+12
 2442 1654 0030A0E3 		mov	r3, #0
 2443 1658 FEFFFFEB 		bl	_txe_thread_create
 2444 165c 0C000BE5 		str	r0, [fp, #-12]
1053:../cyfxbulksrcsink.c ****                           "21:Bulk_src_sink",                      /* Thread ID and thread name */
1054:../cyfxbulksrcsink.c ****                           BulkSrcSinkAppThread_Entry,              /* App thread entry function */
1055:../cyfxbulksrcsink.c ****                           0,                                       /* No input parameter to thread 
1056:../cyfxbulksrcsink.c ****                           ptr,                                     /* Pointer to the allocated thre
1057:../cyfxbulksrcsink.c ****                           CY_FX_BULKSRCSINK_THREAD_STACK,          /* App thread stack size */
1058:../cyfxbulksrcsink.c ****                           CY_FX_BULKSRCSINK_THREAD_PRIORITY,       /* App thread priority */
1059:../cyfxbulksrcsink.c ****                           CY_FX_BULKSRCSINK_THREAD_PRIORITY,       /* App thread priority */
1060:../cyfxbulksrcsink.c ****                           CYU3P_NO_TIME_SLICE,                     /* No time slice for the applica
1061:../cyfxbulksrcsink.c ****                           CYU3P_AUTO_START                         /* Start the thread immediately 
1062:../cyfxbulksrcsink.c ****                           );
1063:../cyfxbulksrcsink.c **** 
1064:../cyfxbulksrcsink.c ****     /* Check the return code */
1065:../cyfxbulksrcsink.c ****     if (ret != 0)
 2445              		.loc 1 1065 0
 2446 1660 0C301BE5 		ldr	r3, [fp, #-12]
 2447 1664 000053E3 		cmp	r3, #0
 2448 1668 0000000A 		beq	.L131
 2449              	.L135:
1066:../cyfxbulksrcsink.c ****     {
1067:../cyfxbulksrcsink.c ****         /* Thread Creation failed with the error code retThrdCreate */
1068:../cyfxbulksrcsink.c **** 
1069:../cyfxbulksrcsink.c ****         /* Add custom recovery or debug actions here */
1070:../cyfxbulksrcsink.c **** 
1071:../cyfxbulksrcsink.c ****         /* Application cannot continue */
1072:../cyfxbulksrcsink.c ****         /* Loop indefinitely */
1073:../cyfxbulksrcsink.c ****         while(1);
 2450              		.loc 1 1073 0 discriminator 1
 2451 166c FEFFFFEA 		b	.L135
 2452              	.L131:
1074:../cyfxbulksrcsink.c ****     }
1075:../cyfxbulksrcsink.c **** }
 2453              		.loc 1 1075 0
 2454 1670 04D04BE2 		sub	sp, fp, #4
 2455 1674 0088BDE8 		ldmfd	sp!, {fp, pc}
 2456              	.L137:
 2457              		.align	2
 2458              	.L136:
 2459 1678 00000000 		.word	glBulkLpEvent
 2460 167c 00000000 		.word	bulkSrcSinkAppThread
 2461 1680 40040000 		.word	.LC23
 2462 1684 00000000 		.word	BulkSrcSinkAppThread_Entry
 2463              		.cfi_endproc
 2464              	.LFE9:
 2466              		.align	2
 2467              		.global	main
 2469              	main:
 2470              	.LFB10:
1076:../cyfxbulksrcsink.c **** 
1077:../cyfxbulksrcsink.c **** /*
1078:../cyfxbulksrcsink.c ****  * Main function
1079:../cyfxbulksrcsink.c ****  */
1080:../cyfxbulksrcsink.c **** int
1081:../cyfxbulksrcsink.c **** main (void)
1082:../cyfxbulksrcsink.c **** {
 2471              		.loc 1 1082 0
 2472              		.cfi_startproc
 2473              		@ args = 0, pretend = 0, frame = 64
 2474              		@ frame_needed = 1, uses_anonymous_args = 0
 2475 1688 00482DE9 		stmfd	sp!, {fp, lr}
 2476              	.LCFI20:
 2477              		.cfi_def_cfa_offset 8
 2478 168c 04B08DE2 		add	fp, sp, #4
 2479              		.cfi_offset 14, -4
 2480              		.cfi_offset 11, -8
 2481              	.LCFI21:
 2482              		.cfi_def_cfa 11, 4
 2483 1690 40D04DE2 		sub	sp, sp, #64
1083:../cyfxbulksrcsink.c ****     CyU3PIoMatrixConfig_t io_cfg;
1084:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 2484              		.loc 1 1084 0
 2485 1694 0030A0E3 		mov	r3, #0
 2486 1698 08300BE5 		str	r3, [fp, #-8]
1085:../cyfxbulksrcsink.c **** 
1086:../cyfxbulksrcsink.c ****     /* Initialize the device */
1087:../cyfxbulksrcsink.c ****     CyU3PSysClockConfig_t clockConfig;
1088:../cyfxbulksrcsink.c ****     clockConfig.setSysClk400  = CyTrue;
 2487              		.loc 1 1088 0
 2488 169c 0130A0E3 		mov	r3, #1
 2489 16a0 40300BE5 		str	r3, [fp, #-64]
1089:../cyfxbulksrcsink.c ****     clockConfig.cpuClkDiv     = 2;
 2490              		.loc 1 1089 0
 2491 16a4 0230A0E3 		mov	r3, #2
 2492 16a8 3C304BE5 		strb	r3, [fp, #-60]
1090:../cyfxbulksrcsink.c ****     clockConfig.dmaClkDiv     = 2;
 2493              		.loc 1 1090 0
 2494 16ac 0230A0E3 		mov	r3, #2
 2495 16b0 3B304BE5 		strb	r3, [fp, #-59]
1091:../cyfxbulksrcsink.c ****     clockConfig.mmioClkDiv    = 2;
 2496              		.loc 1 1091 0
 2497 16b4 0230A0E3 		mov	r3, #2
 2498 16b8 3A304BE5 		strb	r3, [fp, #-58]
1092:../cyfxbulksrcsink.c ****     clockConfig.useStandbyClk = CyFalse;
 2499              		.loc 1 1092 0
 2500 16bc 0030A0E3 		mov	r3, #0
 2501 16c0 38300BE5 		str	r3, [fp, #-56]
1093:../cyfxbulksrcsink.c ****     clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 2502              		.loc 1 1093 0
 2503 16c4 0330A0E3 		mov	r3, #3
 2504 16c8 34304BE5 		strb	r3, [fp, #-52]
1094:../cyfxbulksrcsink.c ****     status = CyU3PDeviceInit (&clockConfig);
 2505              		.loc 1 1094 0
 2506 16cc 40304BE2 		sub	r3, fp, #64
 2507 16d0 0300A0E1 		mov	r0, r3
 2508 16d4 FEFFFFEB 		bl	CyU3PDeviceInit
 2509 16d8 08000BE5 		str	r0, [fp, #-8]
1095:../cyfxbulksrcsink.c ****     if (status != CY_U3P_SUCCESS)
 2510              		.loc 1 1095 0
 2511 16dc 08301BE5 		ldr	r3, [fp, #-8]
 2512 16e0 000053E3 		cmp	r3, #0
 2513 16e4 0000000A 		beq	.L139
1096:../cyfxbulksrcsink.c ****     {
1097:../cyfxbulksrcsink.c ****         goto handle_fatal_error;
 2514              		.loc 1 1097 0
 2515 16e8 290000EA 		b	.L140
 2516              	.L139:
1098:../cyfxbulksrcsink.c ****     }
1099:../cyfxbulksrcsink.c **** 
1100:../cyfxbulksrcsink.c ****     /* Initialize the caches. Enable both Instruction and Data caches. */
1101:../cyfxbulksrcsink.c ****     status = CyU3PDeviceCacheControl (CyTrue, CyTrue, CyTrue);
 2517              		.loc 1 1101 0
 2518 16ec 0100A0E3 		mov	r0, #1
 2519 16f0 0110A0E3 		mov	r1, #1
 2520 16f4 0120A0E3 		mov	r2, #1
 2521 16f8 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 2522 16fc 08000BE5 		str	r0, [fp, #-8]
1102:../cyfxbulksrcsink.c ****     if (status != CY_U3P_SUCCESS)
 2523              		.loc 1 1102 0
 2524 1700 08301BE5 		ldr	r3, [fp, #-8]
 2525 1704 000053E3 		cmp	r3, #0
 2526 1708 0000000A 		beq	.L141
1103:../cyfxbulksrcsink.c ****     {
1104:../cyfxbulksrcsink.c ****         goto handle_fatal_error;
 2527              		.loc 1 1104 0
 2528 170c 200000EA 		b	.L140
 2529              	.L141:
1105:../cyfxbulksrcsink.c ****     }
1106:../cyfxbulksrcsink.c **** 
1107:../cyfxbulksrcsink.c ****     /* Configure the IO matrix for the device. On the FX3 DVK board, the COM port 
1108:../cyfxbulksrcsink.c ****      * is connected to the IO(53:56). This means that either DQ32 mode should be
1109:../cyfxbulksrcsink.c ****      * selected or lppMode should be set to UART_ONLY. Here we are choosing
1110:../cyfxbulksrcsink.c ****      * UART_ONLY configuration. */
1111:../cyfxbulksrcsink.c ****     io_cfg.isDQ32Bit = CyTrue;	//    
 2530              		.loc 1 1111 0
 2531 1710 0130A0E3 		mov	r3, #1
 2532 1714 30300BE5 		str	r3, [fp, #-48]
1112:../cyfxbulksrcsink.c ****     io_cfg.useUart   = CyFalse;	// 
 2533              		.loc 1 1112 0
 2534 1718 0030A0E3 		mov	r3, #0
 2535 171c 2C300BE5 		str	r3, [fp, #-44]
1113:../cyfxbulksrcsink.c ****     io_cfg.useI2C    = CyFalse;
 2536              		.loc 1 1113 0
 2537 1720 0030A0E3 		mov	r3, #0
 2538 1724 28300BE5 		str	r3, [fp, #-40]
1114:../cyfxbulksrcsink.c ****     io_cfg.useI2S    = CyFalse;
 2539              		.loc 1 1114 0
 2540 1728 0030A0E3 		mov	r3, #0
 2541 172c 24300BE5 		str	r3, [fp, #-36]
1115:../cyfxbulksrcsink.c ****     io_cfg.useSpi    = CyFalse;
 2542              		.loc 1 1115 0
 2543 1730 0030A0E3 		mov	r3, #0
 2544 1734 20300BE5 		str	r3, [fp, #-32]
1116:../cyfxbulksrcsink.c ****     io_cfg.lppMode   = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 2545              		.loc 1 1116 0
 2546 1738 0030A0E3 		mov	r3, #0
 2547 173c 1C304BE5 		strb	r3, [fp, #-28]
1117:../cyfxbulksrcsink.c **** 
1118:../cyfxbulksrcsink.c ****     /* No GPIOs are enabled. */
1119:../cyfxbulksrcsink.c ****     io_cfg.gpioSimpleEn[0]  = 0;
 2548              		.loc 1 1119 0
 2549 1740 0030A0E3 		mov	r3, #0
 2550 1744 18300BE5 		str	r3, [fp, #-24]
1120:../cyfxbulksrcsink.c **** 	io_cfg.gpioSimpleEn[1]  = 0;
 2551              		.loc 1 1120 0
 2552 1748 0030A0E3 		mov	r3, #0
 2553 174c 14300BE5 		str	r3, [fp, #-20]
1121:../cyfxbulksrcsink.c **** 	io_cfg.gpioComplexEn[0] = 0;
 2554              		.loc 1 1121 0
 2555 1750 0030A0E3 		mov	r3, #0
 2556 1754 10300BE5 		str	r3, [fp, #-16]
1122:../cyfxbulksrcsink.c **** 	io_cfg.gpioComplexEn[1] = 0;
 2557              		.loc 1 1122 0
 2558 1758 0030A0E3 		mov	r3, #0
 2559 175c 0C300BE5 		str	r3, [fp, #-12]
1123:../cyfxbulksrcsink.c **** 	status = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 2560              		.loc 1 1123 0
 2561 1760 30304BE2 		sub	r3, fp, #48
 2562 1764 0300A0E1 		mov	r0, r3
 2563 1768 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 2564 176c 08000BE5 		str	r0, [fp, #-8]
1124:../cyfxbulksrcsink.c **** 	if (status != CY_U3P_SUCCESS)
 2565              		.loc 1 1124 0
 2566 1770 08301BE5 		ldr	r3, [fp, #-8]
 2567 1774 000053E3 		cmp	r3, #0
 2568 1778 0000000A 		beq	.L142
1125:../cyfxbulksrcsink.c **** 	{
1126:../cyfxbulksrcsink.c **** 		goto handle_fatal_error;
 2569              		.loc 1 1126 0
 2570 177c 040000EA 		b	.L140
 2571              	.L142:
1127:../cyfxbulksrcsink.c **** 	}
1128:../cyfxbulksrcsink.c **** 
1129:../cyfxbulksrcsink.c ****     /* This is a non returnable call for initializing the RTOS kernel */
1130:../cyfxbulksrcsink.c ****     CyU3PKernelEntry ();
 2572              		.loc 1 1130 0
 2573 1780 FEFFFFEB 		bl	_tx_initialize_kernel_enter
1131:../cyfxbulksrcsink.c **** 
1132:../cyfxbulksrcsink.c ****     /* Dummy return to make the compiler happy */
1133:../cyfxbulksrcsink.c ****     return 0;
 2574              		.loc 1 1133 0
 2575 1784 0030A0E3 		mov	r3, #0
1134:../cyfxbulksrcsink.c **** 
1135:../cyfxbulksrcsink.c **** handle_fatal_error:
1136:../cyfxbulksrcsink.c **** 
1137:../cyfxbulksrcsink.c ****     /* Cannot recover from this error. */
1138:../cyfxbulksrcsink.c ****     while (1);
1139:../cyfxbulksrcsink.c **** }
 2576              		.loc 1 1139 0
 2577 1788 0300A0E1 		mov	r0, r3
 2578 178c 04D04BE2 		sub	sp, fp, #4
 2579 1790 0088BDE8 		ldmfd	sp!, {fp, pc}
 2580              	.L140:
1138:../cyfxbulksrcsink.c ****     while (1);
 2581              		.loc 1 1138 0 discriminator 1
 2582 1794 FEFFFFEA 		b	.L140
 2583              		.cfi_endproc
 2584              	.LFE10:
 2586              		.bss
 2587              		.align	2
 2588              	num_connect.6990:
 2589 0024 00000000 		.space	4
 2590              		.align	2
 2591              	num_disconnect.6991:
 2592 0028 00000000 		.space	4
 2593              		.text
 2594              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 cyfxbulksrcsink.c
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:26     .data:00000000 CyFxGpifTransition
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:23     .data:00000000 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:34     .data:00000008 CyFxGpifWavedata
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:57     .data:00000050 CyFxGpifWavedataPosition
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:66     .data:00000054 CyFxGpifRegValue
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:148    .rodata:00000000 CyFxGpifConfig
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:145    .rodata:00000000 $d
                            *COM*:000000a8 bulkSrcSinkAppThread
                            *COM*:000000a0 glChHandleBulkSink
                            *COM*:000000a0 glChHandleBulkSrc
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:167    .bss:00000000 glIsApplnActive
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:164    .bss:00000000 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:173    .bss:00000004 glDMARxCount
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:179    .bss:00000008 glDMATxCount
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:185    .bss:0000000c glDataTransStarted
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:191    .bss:00000010 StandbyModeEnable
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:197    .bss:00000014 TriggerStandbyMode
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:203    .bss:00000018 glForceLinkU2
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:209    .bss:0000001c glEp0StatCount
                            *COM*:00000020 glEp0Buffer
                            *COM*:00000028 glBulkLpEvent
                            *COM*:00000004 gl_setupdat0
                            *COM*:00000004 gl_setupdat1
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:219    .bss:00000020 gl_UsbLogBuffer
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:222    .text:00000000 $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:225    .text:00000000 CyFxAppErrorHandler
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:268    .text:0000001c CyFxBulkSrcSinkDmaCallback
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:371    .text:00000128 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:394    .text:00000140 $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:397    .text:00000140 CyFxBulkSrcSinkApplnStart
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:740    .text:000004e4 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:756    .text:00000518 $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:759    .text:00000518 CyFxBulkSrcSinkApplnStop
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:846    .text:000005ec $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:853    .text:000005fc $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:856    .text:000005fc CyFxBulkSrcSinkApplnUSBSetupCB
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1072   .text:0000083c $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1091   .text:0000085c $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1094   .text:0000085c CyFxBulkSrcSinkApplnUSBEventCB
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1119   .text:00000888 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1134   .text:000008bc $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1240   .text:000009d0 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:2588   .bss:00000024 num_connect.6990
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:2591   .bss:00000028 num_disconnect.6991
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1253   .text:000009f8 $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1256   .text:000009f8 CyFxBulkSrcSinkApplnLPMRqtCB
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1330   .text:00000a20 CyFxBulkSrcSinkApplnInit
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1678   .text:00000de8 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1717   .text:00000e58 $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1720   .text:00000e58 BulkSrcSinkAppThread_Entry
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1838   .text:00000f98 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:1947   .text:00001144 $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:2359   .text:00001588 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:2382   .text:000015c4 $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:2385   .text:000015c4 CyFxApplicationDefine
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:2459   .text:00001678 $d
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:2466   .text:00001688 $a
C:\Users\209\AppData\Local\Temp\ccXupNbw.s:2469   .text:00001688 main
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_tx_thread_sleep
CyU3PDmaChannelDiscardBuffer
CyU3PDebugPrint
CyU3PDmaChannelGetBuffer
CyU3PDmaChannelCommitBuffer
CyU3PUsbGetSpeed
CyU3PMemSet
CyU3PSetEpConfig
CyU3PUsbFlushEp
CyU3PDmaChannelCreate
CyU3PDmaChannelSetXfer
CyU3PDmaChannelDestroy
CyU3PUsbAckSetup
CyU3PUsbStall
CyU3PDmaChannelReset
CyU3PUsbResetEp
_txe_event_flags_set
CyU3PUsbStart
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbRegisterLPMRequestCallback
CyU3PUsbSetDesc
CyU3PDmaBufferAlloc
CyU3PUsbInitEventLog
CyU3PConnectState
CyFxUSB30DeviceDscr
CyFxUSB20DeviceDscr
CyFxUSBBOSDscr
CyFxUSBDeviceQualDscr
CyFxUSBSSConfigDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
_txe_event_flags_get
CyU3PUsbSendDevNotification
CyU3PUsbDoRemoteWakeup
CyU3PMemCopy
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PUsbGetEventLogIndex
CyU3PReadDeviceRegisters
CyU3PUsbGetBooterVersion
CyU3PDebugDeInit
CyU3PUartDeInit
CyU3PUsbSetBooterSwitch
CyU3PUsbJumpBackToBooter
CyU3PDeviceReset
CyU3PUsbGetLinkPowerState
CyU3PUsbSetLinkPowerState
CyU3PUsbStop
CyU3PSysEnterStandbyMode
_txe_event_flags_create
CyU3PMemAlloc
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
